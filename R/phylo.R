.packageName <- "phangorn"

.onLoad  <- function(libname, pkgname) {
    library.dynam("phangorn", pkgname, libname)
    require(ape) 
    require(quadprog)
}


dec2bin <- function(x){
    res=" "
    i = 1
    while(x>0){
        if(x %% 2) res = paste(res, as.character(i))
            x = x %/% 2 
            i=i+1
	    }
        res
    }  



"ldfactorial" <- function(x){
	x = (x+1)/2
	res = lgamma(2*x)-(lgamma(x)+(x-1)*log(2))
	res
}


"dfactorial" <- function(x){exp(ldfactorial(x))}


#
# Hadamard Conjugation
#

hadamard <- function(x){
	res=1
	while(x>0){
		res=rbind(cbind(res,res),cbind(res,-res))
		x=x-1
	}
	res
}


fhm <- function(v){
	n = length(v)
	n = log2(n)
	res = .C("fhm", v = as.double(v), n = as.integer(n), PACKAGE = "phangorn")$v
	res
}


seq2split = function(s){
	n=length(s)
	res= fhm(log(fhm(s)))/n
	res
}


split2seq = function(q){
	n=length(q)
	res= fhm(exp(fhm(q)))/n
	res
}


distanceHadamard <- function (dm) 
{
    if (class(dm) == "dist") {
        n <- attr(dm, "Size")
        Labels = attr(dm, "Labels")
    }
    if (class(dm) == "matrix") {
        n <- dim(dm)[1]
        dm <- dm[lower.tri(dm)]
        Labels <- colnames(dm)
    }
    ns <- 2^(n - 1)
    if (n > 23) 
        stop("Hadamard conjugation works only efficient for n < 24")
    result <- .Call("dist2spectra", dm, as.integer(n), as.integer(ns), 
        PACKAGE = "phangorn")
    res <- data.frame(distance = result, edges = -fhm(result)/2^(n - 
        2), index = 0:(ns - 1))
    attr(result, "Labels") <- Labels
    res
}


h4st = function(obj, levels=c('a','c','g','t')){
	if(is.matrix(obj)) obj = as.data.frame(t(obj))

	DNA = as.data.frame(obj)
	n = dim(DNA)[1]
	p = dim(DNA)[2]

	if(p>11) stop("4-state Hadamard conjugation works only efficient for n < 12")

	DNAX = matrix(0,n,p)
	DNAY = matrix(0,n,p)

	DNAX[DNA==levels[1]]=0
	DNAX[DNA==levels[2]]=1
	DNAX[DNA==levels[3]]=1
	DNAX[DNA==levels[4]]=0

	DNAY[DNA==levels[1]]=0
	DNAY[DNA==levels[2]]=1
	DNAY[DNA==levels[3]]=0
	DNAY[DNA==levels[4]]=1

	DNAY = DNAY - DNAY[,p]
	DNAX = DNAX - DNAX[,p]

	DNAY = abs(DNAY[,-p])
	DNAX = abs(DNAX[,-p])
	dy = DNAY %*% (2^(0:(p-2))) 
	dx = DNAX %*% (2^(0:(p-2))) 

	INDEX =  dx + 2^(p-1) * dy
	blub = table(INDEX)
	index = as.numeric(rownames(blub)) + 1
	sv = numeric(4^(p-1))
	sv[index] = blub
	qv = matrix(seq2split(sv),2^(p-1),2^(p-1))
	sv = matrix(sv,2^(p-1),2^(p-1))

	q = cbind(transversion = qv[-1,1], transition.1 = diag(qv)[-1], transition.2 = qv[1,-1])
	result = list(q = q, qv = qv, sv=sv, n=sum(sv), names=names(obj))
	result
}


h2st = function (obj, levels = c("r", "y")) 
{
    if (is.matrix(obj)) 
        obj = as.data.frame(t(obj))
    obj = as.data.frame(obj)
    n = dim(obj)[1]
    p = dim(obj)[2]
    if (p > 23) 
        stop("Hadamard conjugation works only efficient for n < 24")
    DNAX = matrix(0, n, p)
    DNAX[obj == levels[1]] = 0
    DNAX[obj == levels[2]] = 1
    DNAX = DNAX - DNAX[, p]
    DNAX = abs(DNAX[, -p])
    dx = DNAX %*% (2^(0:(p - 2)))
    INDEX = dx 
    blub = table(INDEX)
    index = as.numeric(rownames(blub)) + 1
    sv = numeric(2^(p - 1))
    sv[index] = blub
    qv = seq2split(sv)
    result = data.frame(edges = qv, splits=sv, index = 0:(2^(p-1)-1))
    attr(result,"Labels") = names(obj)
    result
}


write.nexus.splits = function (obj, file = "") 
{
    dec2bin <- function(x) {
        res = " "
        i = 1
        while (x > 0) {
            if (x%%2) 
                res = paste(res, as.character(i))
            x = x%/%2
            i = i + 1
        }
        res
    }
    splits <- lapply(obj$index, dec2bin)
 
    weight <- obj$edges
    taxa.labels <- attr(obj, "Labels")
    ntaxa = length(taxa.labels)
    nsplits = length(splits)
    if (is.null(weight)) 
        weight = numeric(nsplits) + 100
    cat("#NEXUS\n\n", file = file)
    cat("[Splits block for Spectronet]\n", file = file, append = TRUE)
    cat("[generated by ]\n", file = file, append = TRUE)
    cat(paste("[", attr(citation("phangorn"), "textVersion"), 
        "]\n\n", sep = ""), file = file, append = TRUE)
    cat(paste("BEGIN TAXA;\n\tDIMENSIONS NTAX=", ntaxa, ";\n", 
        sep = ""), file = file, append = TRUE)
    cat("\tTAXLABELS", paste(taxa.labels, sep = " "), ";\nEND;\n\n", 
        file = file, append = TRUE)
    cat(paste("BEGIN ST_SPLITS;\n\tDIMENSIONS NSPLITS=", nsplits, 
        ";\n", sep = ""), file = file, append = TRUE)
    cat("\tFORMAT LABELS WEIGHTS;\n\tMATRIX\n", file = file, 
        append = TRUE)
    for (i in 1:nsplits) cat("\t\t", i, weight[i], paste(splits[[i]]), 
        ",\n", file = file, append = TRUE)
    cat("\t;\nEND;\n", file = file, append = TRUE)
}


#
# tree distance functions
#

treedist <- function (tree1, tree2) 
{
	tree1 = unroot(tree1)
    tree2 = unroot(tree2)
    symmetric.difference = NULL
    branch.score.difference = NULL
    path.difference = NULL
    quadratic.path.difference = NULL

    o1 = order(tree1$tip.label)
    o2 = order(tree2$tip.label)
    ll = length(o1)
    p1 = bipartition(tree1)
    p2 = bipartition(tree2)
    p = dim(p1)[1]
    M1 = p1[, o1]
    M2 = p2[, o2]
    if (!is.null(tree1$edge.length) & !is.null(tree2$edge.length)) {
        v1 = tree1$edge.length
        v2 = tree2$edge.length
        dv1 = t(M1 * v1) %*% ((1 - M1) * v1) + t((1 - M1) * v1) %*% 
            (M1 * v1)
        dv2 = t(M2 * v2) %*% ((1 - M2) * v2) + t((1 - M2) * v2) %*% 
            (M2 * v2)
        quadratic.path.difference = sqrt(sum((dv1 - dv2)^2)/2)
    }
    R = M1 %*% t(M2) + (1 - M1) %*% t(1 - M2)
    R = (R%%ll == 0)
    r1 = rowSums(R) > 0
    r2 = colSums(R) > 0
    symmetric.difference = 2 * (p - sum(r1))
    if (!is.null(tree1$edge.length) & !is.null(tree2$edge.length)) {
        v1 = tree1$edge.length
        v2 = tree2$edge.length
        ind1 <- (1:p)[r1]
        ind2 <- unlist(apply(R, 1, which, TRUE))
        s1 = sum((v2[ind2] - v1[ind1])^2)
        zaehler = abs(v2[ind2] - v1[ind1])
        nenner = (v2[ind2] + v1[ind1])/2
        difference = matrix(0, sum(r1), 4)
        difference[, 1] = zaehler
        difference[, 2] = nenner
        difference[, 3] = ind1
        difference[, 4] = ind2
        s2 = sum((v1[(1:p)[!r1]])^2)
        s3 = sum((v2[(1:p)[!r2]])^2)
        branch.score.difference = sqrt(s1 + s2 + s3)
    }
    M1[M1 == 0] = -1
    M2[M2 == 0] = -1
    dt1 = (p - t(M1) %*% M1)/2
    dt2 = (p - t(M2) %*% M2)/2
    path.difference = sqrt(sum((dt1 - dt2)^2)/2)
    result = list(symmetric.difference = symmetric.difference, 
        branch.score.difference = branch.score.difference, path.difference = path.difference, 
        quadratic.path.difference = quadratic.path.difference)
    class(result)="treedist"
    result              
}


print.treedist <- function(x,...){
    cat("Symmetric difference:", x$symmetric.difference, "\n")
    cat("Branch score difference:", x$branch.score.difference, "\n")
    cat("Path difference:", x$path.difference, "\n")
    cat("Weighted path difference:", x$quadratic.path.difference, "\n")
}



#
# UPGMA, NJ and UNJ
#

"upgma" <- function(D,method="average",...){
	DD=as.dist(D)
	hc = hclust(DD,method=method,...)
	result = as.phylo(hc)
	result = reorder(result, "pruningwise")
	result$edge.length=result$edge.length/2
	result
}


NJ <- function (x) 
{
    x = as.matrix(x)
    labels <- attr(x, "Labels")[[1]]
    edge.length = NULL
    edge = NULL
    d = as.matrix(x)
    if (is.null(labels)) 
        labels = colnames(d)
    l = dim(d)[1]
    m = l - 2
    nam = 1:l
    k = 2 * l - 2
    while (l > 2) {
        r = rowSums(d)/(l - 2)
        i = 0
        j = 0
        tmp <- .C("out", as.double(d), as.double(r), as.integer(l), 
            as.integer(i), as.integer(j), PACKAGE = "phangorn")
        e2 = tmp[[5]]
        e1 = tmp[[4]]
        l1 = d[e1, e2]/2 + (r[e1] - r[e2])/(2)
        l2 = d[e1, e2] - l1
        edge.length = c(l1, l2, edge.length)
        edge = rbind(c(k, nam[e2]), edge)
        edge = rbind(c(k, nam[e1]), edge)
        nam = c(nam[c(-e1, -e2)], k)
        dnew = (d[e1, ] + d[e2, ] - d[e1, e2])/2
        d = cbind(d, dnew)
        d = rbind(d, c(dnew, 0))
        d = d[-c(e1, e2), -c(e1, e2)]
        k = k - 1
        l = l - 1
    }
    edge.length = c(d[2, 1], edge.length)
    attr(edge.length,"names") = NULL
    result = list(edge = rbind(c(nam[2], nam[1]), edge), edge.length = edge.length,
     tip.label = labels, Nnode = m)
    class(result) <- "phylo"
    # test 
    reorder(result, "pruningwise")
}


UNJ = function (x) 
{
    x = as.matrix(x)
    labels <- attr(x, "Labels")[[1]]
    edge.length = NULL
    edge = NULL
    d = as.matrix(x)
    if (is.null(labels)) 
        labels = colnames(d)
    l = dim(d)[1]
    n = l
    nam = as.character(1:l)
    m=l-2
	nam = 1:l
	k = 2*l-2       
    w = rep(1,l)
    while (l > 2) {
        r = rowSums(d)/(l - 2)
        i = 0
        j = 0
        tmp <- .C("out", as.double(d), as.double(r), as.integer(l), as.integer(i), as.integer(j), PACKAGE = "phangorn")
        e2 = tmp[[5]]
        e1 = tmp[[4]]
        l1 = d[e1, e2]/2 + sum((d[e1,-c(e1,e2)] - d[e2,-c(e1,e2)])*w[-c(e1,e2)])/(2*(n-w[e1]-w[e2]))
        l2 = d[e1, e2]/2 + sum((d[e2,-c(e1,e2)] - d[e1,-c(e1,e2)])*w[-c(e1,e2)])/(2*(n-w[e1]-w[e2]))
        edge.length = c(l1, l2, edge.length)
        edge = rbind(c(k, nam[e2]), edge)
        edge = rbind(c(k, nam[e1]), edge)
        nam = c(nam[c(-e1, -e2)], k)
      
        dnew = (w[e1]*d[e1, ] + w[e2]*d[e2, ] - w[e1]*l1 - w[e2]*l2)/(w[e1] + w[e2])
        d = cbind(d, dnew)
        d = rbind(d, c(dnew, 0))
        d = d[-c(e1, e2), -c(e1, e2)]
        w = c(w, w[e1] + w[e2])
        w = w[-c(e1, e2)]
        k = k - 1
        l = l - 1
    }
    edge.length=c(d[2,1],edge.length)
    result = list(edge = rbind(c(nam[2], nam[1]), edge), 
    edge.length=edge.length, tip.label = labels, Nnode=m)
    class(result) <- "phylo"
    reorder(result, "pruningwise")  
}


"dist.hamming" <- function (x, ratio = TRUE) 
{
    if(class(x)!='phyDat') stop("x has to be element of class phyDat")
    l = length(x)
    weight <- attr(x, 'weight')
    d = numeric((l * (l - 1))/2)
    k = 1
    for (i in 1:(l - 1)) {
        for (j in (i + 1):l) {
            d[k] = sum( weight * (rowSums(x[[i]] * x[[j]])==0))
            k = k + 1
        }
    }
    if (ratio) 
        d = d/sum(weight)
    attr(d, "Size") <- l
    if (is.list(x)) 
        attr(d, "Labels") <- names(x)
    else attr(d, "Labels") <- colnames(x)
    attr(d, "Diag") <- FALSE
    attr(d, "Upper") <- FALSE
    attr(d, "call") <- match.call()
    attr(d, "method") <- "hamming"
    class(d) <- "dist"
    return(d)
}


dist.tip <- function(x1,x2,weight,el, eig=edQt(), bf){
    d = crossprod(x1*weight,x2)
    ll0 <- sum(d * log(getP(el,eig)[[1]]*bf))
    eps=1
    el = 1 - (sum(diag(d)) / sum(d))
#    if(sum(d)==sum(diag(d))){
    if(el==0){
# 	 ll1 <- sum(d * log(getP(el,eig)[[1]] * bf))   
        ll1 <- sum(d * log(getP(el,eig)[[1]] * bf))
        return(c(0, 0, ll0, ll1))
        } 
    while(eps>1e-6){     
         f = getP(el,eig)[[1]]*bf
         df = getdP(el,eig)[[1]]*bf
         d2f = getd2P(el,eig)[[1]]*bf
         dl = sum(d*(df/f))
         d2l = sum(d* ((f*d2f) - df^2)/(f^2))
         el1 = log(el) - dl/d2l
         el1= exp(el1)
         eps = abs(el1-el)         
         el=el1
    }
    ll1  <- sum(d * log(getP(el1,eig)[[1]]*bf))
    c(el, d2l, ll0, ll1)
}


dist.ml <- function(x, model="JC69",...){
    if (class(x) != "phyDat") 
        stop("x has to be element of class phyDat")
    l = length(x)
    weight <- attr(x, "weight")
    nr <- attr(x, "nr")
    nc <- attr(x, "nc")
    ll.0 <- numeric(length(weight))
    w=1
    g=1
    d = numeric((l * (l - 1))/2)
    v = numeric((l * (l - 1))/2) 
    type <- attr(x,"type")
    model <- match.arg(model, c("JC69", "WAG", "JTT", "LG", "Dayhoff"))   
        model <- match.arg(model, c("JC69", "WAG", "JTT", "LG", "Dayhoff"))
        if (model == "WAG") {
            Q <- .WAG$Q
#            if(is.null(bf))
            bf <- .WAG$bf
        }
        if (model == "JTT") {
            Q <- .JTT$Q
#            if(is.null(bf))
            bf <- .JTT$bf
        }
        if (model == "LG") {
            Q <- .LG$Q
#            if(is.null(bf))
            bf <- .LG$bf
        }
        if (model == "Dayhoff") {
            Q <- .Dayhoff$Q
#            if(is.null(bf))
            bf <- .Dayhoff$bf
        }
    if(model == "JC69"){
        bf = c(.25,.25,.25,.25)
        Q = rep(1,6)
    }
    eig <- edQt(Q=Q, bf=bf)
    old.el <- 0.1
    k = 1
    for (i in 1:(l - 1)) {
        for (j in (i + 1):l) {
            tmp <- dist.tip(x[[i]],x[[j]], weight, old.el, eig=eig, bf)
            d[k] <- tmp[1] 
            v[k] <- tmp[2]  
            k = k + 1
        }
    }
    attr(d, "Size") <- l
    if (is.list(x)) 
        attr(d, "Labels") <- names(x)
    else attr(d, "Labels") <- colnames(x)
    attr(d, "Diag") <- FALSE
    attr(d, "Upper") <- FALSE
    attr(d, "call") <- match.call()
    attr(d, "method") <- model
    attr(d, "var") <- v
    class(d) <- "dist"
    return(d)   
}



"dist.logDet" <- function(x){
    if(class(x)!='phyDat') stop("x has to be element of class phyDat")
    weight <- attr(x, 'weight')
    r <- attr(x,"nc")
    l = length(x)
    d = numeric((l * (l - 1))/2)
    k = 1
    for (i in 1:(l - 1)) {
        for (j in (i + 1):l) {
            tmp = crossprod(weight * x[[i]],x[[j]])
			class(tmp) = 'matrix'
			if(is.nan( log(det(tmp)) ) ){
			d[k] = 10
			}	
            else d[k] = (-log(det(tmp)) + sum(log(rowSums(tmp) * colSums(tmp)))/2)/r
            k = k + 1
        }
    }
    attr(d, "Size") <- l
    if (is.list(x)) 
        attr(d, "Labels") <- names(x)
    else attr(d, "Labels") <- colnames(x)
    attr(d, "Diag") <- FALSE
    attr(d, "Upper") <- FALSE
    attr(d, "call") <- match.call()
    attr(d, "method") <- "logDet"
    class(d) <- "dist"
    return(d)
}



splitsNetwork <- function(dm, gamma=.1, lambda=0.001){
    dm = as.matrix(dm)
    k = dim(dm)[1]
    X2 = designAll(k)
    X=X2[[1]]
    
    y = dm[lower.tri(dm)]
    ind = c(2^(0:(k-2)),2^(k-1)-1)
    y2 = lm(y~X[,ind]-1)$res
    n = dim(X)[2]

    ridge      <- lambda * diag(n) 
    ridge[ind,ind] <- 0
    Dmat       <- crossprod(X) + ridge
    dvec       <- crossprod(X,y)
    ind1       <- rep(1,n)
    ind1[ind]  <- 0 

    Amat       <- cbind(ind1,diag(n)) 
    bvec       <- c(gamma, rep(0,n))

    solution <- solve.QP(Dmat,dvec,Amat,bvec=bvec, meq=1)$sol   
    
    ind2 <- which(solution>1e-8)
    n2 <- length(ind2)

    ind3 = which(duplicated(c(ind2, ind), fromLast = TRUE)[1:n2])
    ridge2 <- lambda * diag(n2) 
    ridge2[ind3,ind3] <- 0
    Dmat2 <-  crossprod(X[, ind2]) + ridge2
    dvec2 <- crossprod(X[, ind2], y)
    Amat2 <- diag(n2)
    bvec2 <- rep(0, n2)
    solution2  <- solve.QP(Dmat2, dvec2, Amat2)$sol
    result <- data.frame(index=ind2, edges=solution2, pen.edges=solution[ind2])
    attr(result,"Labels") <- dimnames(dm)[[1]]
    result
}



#
# Data structures for ML and MP
# 

fast.table <- function (data)                                                            
{                                                                                        
	if(is.list(data))data = as.data.frame(data, stringsAsFactors=FALSE)                    
	da = do.call("paste", c(data, sep = "\r"))                                             
	ind = !duplicated(da)                                                                  
	levels = da[ind]                                                                       
	cat <- factor(da,levels = levels)                                                      
	nl <- length(levels(cat))                                                        
	bin <- (as.integer(cat) - 1)                                                           
	pd <- nl                                                                               
	bin <- bin[!is.na(bin)]                                                                
	if (length(bin)) bin <- bin + 1                                                        
	y <- tabulate(bin, pd)                                                                 
	result=list(index = bin, weights = y, data = data[ind,])	                                                                              
	result                                                                                 
}                                                                                        
                                                                   

phyDat.DNA = function (data, return.index = FALSE) 
{
    if (class(data) == "DNAbin") 
        data = as.character(data)
    if (is.matrix(data)) 
        data = as.data.frame(t(data))
    ac = c("a", "c", "g", "t", "u", "m", "r", "w", "s", "y", 
        "k", "v", "h", "d", "b", "n", "?", "-")
    AC = matrix(c(c(1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 
        0, 1, 1, 1), c(0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 
        0, 1, 1, 1, 1), c(0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 
        0, 1, 1, 1, 1, 1), c(0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 
        0, 1, 1, 1, 1, 1, 1)), 18, 4, 
        dimnames = list(NULL, c("a", "c", "g", "t")))
    data = as.data.frame(data, stringsAsFactors = FALSE)
    nam = names(data)
    ddd = fast.table(data)
    data = ddd$data
    index = ddd$index
    q = length(data)
    p = length(data[[1]])
    tmp <- vector("list", q)
    for (i in 1:q) tmp[[i]] = factor(data[[i]], levels = ac)
    data <- tmp
    for (i in 1:q) class(data[[i]]) = "integer"
    class(data) <- "data.frame"
    row.names(data) = as.character(1:p)
    data = na.omit(data)
    rn = as.numeric(rownames(data))
    ind = which(!duplicated(c(rn, as.character(unique(index)))))
    ind = ind - length(rn)
    ind = ind[ind > 0]
    for (i in 1:length(ind)) index[which(index == ind[i])] = NA    
    indextmp = diff(sort(unique(index)))
    l1 = which(indextmp > 1)
    d1 = indextmp[l1]
    if (length(l1) > 0) {
        for (i in 1:length(l1)) {
            index[index > l1[i] & !is.na(index)] = index[index > 
                l1[i] & !is.na(index)] - (d1[i] - 1)
        }
    }
    weight = ddd$weight[rn]
    p = dim(data)[1]
    dat = list()
    for (i in 1:q) dat[[i]] = AC[data[[i]],]
    names(dat) = nam
    attr(dat, "weight") = weight
    attr(dat, "nr") = p
    attr(dat, "nc") = 4
    if (return.index) 
        attr(dat, "index") = index
    attr(dat, "levels") = c("a", "c", "g", "t")
    attr(dat, "type") = "DNA"
    class(dat) = "phyDat"
    dat
}



phyDat.AA <- function (data, return.index = FALSE) 
{
    if (class(data) == "DNAbin") 
        data = as.character(data)
    if (is.matrix(data)) 
        data = as.data.frame(t(data))
    aa <- c("a", "r", "n", "d", "c", "q", "e", "g", "h", "i", 
        "l", "k", "m", "f", "p", "s", "t", "w", "y", "v")
    aa2 <- c("a", "r", "n", "d", "c", "q", "e", "g", "h", "i", 
        "l", "k", "m", "f", "p", "s", "t", "w", "y", "v", "b", 
        "z", "x", "-", "?")
    AA <- diag(20)
    AA <- rbind(AA, matrix(0, 5, 20))
    AA[21, 3] <- AA[21, 4] <- 1 # Aspartate or Asparagine
    AA[22, 6] <- AA[22, 7] <- 1 #
    AA[23:25, ] = 1
    dimnames(AA) <- list(NULL, aa)
    data = as.data.frame(data, stringsAsFactors = FALSE)
    nam = names(data)
    ddd = fast.table(data)
    data = ddd$data
    index = ddd$index
    q = length(data)
    p = length(data[[1]])
    tmp <- vector("list", q)
    for (i in 1:q) tmp[[i]] = factor(data[[i]], levels = aa2)
    data <- tmp
    for (i in 1:q) class(data[[i]]) = "integer"
    class(data) <- "data.frame"
    row.names(data) = as.character(1:p)
    data = na.omit(data)
    rn = as.numeric(rownames(data))
    ind = which(!duplicated(c(rn, as.character(unique(index)))))
    ind = ind - length(rn)
    ind = ind[ind > 0]
    for (i in 1:length(ind)) index[which(index == ind[i])] = NA
    indextmp = diff(sort(unique(index)))
    l1 = which(indextmp > 1)
    d1 = indextmp[l1]
    if (length(l1) > 0) {
        for (i in 1:length(l1)) {
            index[index > l1[i] & !is.na(index)] = index[index > 
                l1[i] & !is.na(index)] - (d1[i] - 1)
        }
    }
    weight = ddd$weight[rn]
    p = dim(data)[1]
    dat = list()
    for (i in 1:q) dat[[i]] = AA[data[[i]], ]
    names(dat) = nam
    attr(dat, "weight") = weight
    attr(dat, "nr") = p
    attr(dat, "nc") = 20
    if (return.index) 
        attr(dat, "index") = index
    attr(dat, "levels") = aa
    attr(dat, "type") = "AA"
    class(dat) = "phyDat"
    dat
}



as.phyDat <- function (x, ...) UseMethod("as.phyDat")


as.phyDat.DNAbin <- function(x,...) phyDat.DNA(x,...)


as.data.frame.phyDat <- function(x, ...){
        lev = attr(x,"levels")
        fn = function(x, levels, y) paste(levels[x*y], collapse="")               
        nr = attr(x, "nr")
        nc = attr(x, "nc")
        y = 1:nc
        X = matrix(nrow=nr, ncol=length(x))
        for(i in 1:length(x)) X[,i]= apply(x[[i]], 1, fn, lev, y)
        if(is.null(attr(x,"index"))) index=rep(1:nr, attr(x,"weight"))
        else index = attr(x,"index")
        result = X[index,]
        colnames(result) = names(x)
        result = as.data.frame(result, stringsAsFactors = FALSE)
        result
}



as.character.phyDat <- function (x, ...) 
{
    nr <- attr(x, "nr")
    nc <- attr(x, "nc")
    type <- attr(x, "type")
    if (type == "DNA") {
        labels <- c("a", "c", "g", "t", "t", "m", "r", "w", "s", 
            "y", "k", "v", "h", "d", "b", "n", "-")
        levels <- matrix(c(c(1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 
            1, 1, 1, 0, 1, 0), c(0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 
            0, 1, 1, 0, 1, 1, 0), c(0, 0, 1, 0, 0, 0, 1, 0, 1, 
            0, 1, 1, 0, 1, 1, 1, 0), c(0, 0, 0, 1, 1, 0, 0, 1, 
            0, 1, 1, 0, 1, 1, 1, 1, 0)), 17, 4, dimnames = list(NULL, 
            c("a", "c", "g", "t")))
        levels <- levels %*% (2^c(0:3)) 
    }
    if (type == "AA") {
        labels <- c("a", "r", "n", "d", "c", "q", "e", "g", "h", 
            "i", "l", "k", "m", "f", "p", "s", "t", "w", "y", 
            "v", "b", "z", "x")
        AA <- diag(20)
        AA <- rbind(AA, matrix(0, 3, 20))
        AA[21, 3] <- AA[21, 4] <- 1
        AA[22, 6] <- AA[22, 7] <- 1
        AA[23, ] = 1
        levels <- AA %*% (2^c(0:19)) 
    }
    if(type == "USER"){
        labels = attr(x, "levels")
        levels <- 1:nc
    }
    y = 1:nc
    X = matrix(nrow = length(x), ncol = nr)
    if(type=="AA" | type=="DNA") for (i in 1:length(x)) X[i,] <- x[[i]] %*% (2^c(0:(nc-1)))
    else  for (i in 1:length(x)) X[i,] <- x[[i]] %*% c(1:nc)
    result = matrix(NA, nrow = length(x), ncol = nr)
    for(i in 1:length(labels)) result[X==levels[i]] <- labels[i]

    if (is.null(attr(x, "index"))) 
        index = rep(1:nr, attr(x, "weight"))
    else {
        index = attr(x, "index")
        if (is.data.frame(index)) 
            index <- index[, 1]
    }
    result = result[, index]
    rownames(result) = names(x)
    result
}



phyDat <- function (data, type="DNA", levels=NULL, return.index = FALSE,...) 
{
    if (class(data) == "DNAbin") type <- "DNA"
    pt <- match.arg(type, c("DNA", "AA", "USER"))  
    if(pt=="DNA") dat <- phyDat.DNA(data, return.index=return.index,...)
    if(pt=="AA") dat <- phyDat.AA(data, return.index=return.index, ...)
    if(pt=="USER") dat <- phyDat.default(data, type="USER", levels = levels, return.index=return.index, ...)
    dat
}


phyDat.default = function(data, levels, type="USER", return.index=FALSE){
	# new ape format
	if(class(data)=="DNAbin") data = as.character(data)
	# old ape format 
	if(is.matrix(data)) data = as.data.frame(t(data))                                                                   
	data = as.data.frame(data, stringsAsFactors=FALSE)
    nam = names(data) 	                                     
	ddd = fast.table(data)                                                                 
	data = ddd$data                                                                        
	weight = ddd$weight  
	index = ddd$index                                                                
  	q = length(data)                                                                       
    p = length(data[[1]])
    tmp <- vector("list", q)
    for (i in 1:q) tmp[[i]] = factor(data[[i]], levels = levels)
    data <- tmp
    for (i in 1:q) class(data[[i]]) = "integer"
    class(data) <- "data.frame"    
                                                                       
    row.names(data) = as.character(1:p)
    data = na.omit(data)
    rn = as.numeric(rownames(data))
    ind = which(!duplicated(c(rn,as.character(unique(index)))))
	ind = ind-length(rn)
	ind = ind[ind>0]
    for(i in 1:length(ind)) index[which(index==ind[i])] = NA
    indextmp = diff(sort(unique(index)))
	l1 = which(indextmp>1)
	d1 = indextmp[l1]
	if(length(l1)>0){
		for(i in 1:length(l1)){
			index[index>l1[i] & !is.na(index)] = index[index>l1[i] & !is.na(index)] - (d1[i]-1)
		}
	}	   
	weight = ddd$weight[rn]
                                                               
    p = dim(data)[1]                                                                     
    dat = list()                                                                         
    l = length(levels)                                                                   
    AACC = diag(l)                                                                       
    for (i in 1:q) dat[[i]] = matrix(unlist(AACC[,data[[i]]], TRUE, FALSE), ncol = l, 
    	byrow = TRUE)                                                                            
    names(dat) = nam                     
    attr(dat,"weight") = weight  
    attr(dat,"nr") = p
    attr(dat,"nc") = length(levels)
    if(return.index) attr(dat,"index") = index
    attr(dat, "levels") = levels 
    attr(dat, "type") = type                                                            
    class(dat) = "phyDat"
    dat                                                                               
}


print.phyDat = function (x, ...) 
{
    cat(length(x), "sequences with",sum(attr(x,"weight")), "character and",attr(x,"nr"),"different site patterns.\n")
    cat("The states are",attr(x,"levels"), "\n")
}


c.phyDat <- function(...){
    object <- as.list(substitute(list(...)))[-1]    
    x <- list(...)
    n <- length(x) 
    match.names <- function(clabs, nmi) {
        if (identical(clabs, nmi)) NULL
        else stop("names do not match previous names")
    }
    if (n == 1) 
        return(x[[1]])
    type <- attr(x[[1]], "type")
    nr = numeric(n)
    nr[1] <- sum(attr(x[[1]], "weight"))
    levels <- attr(x[[1]], "levels")
    snames <- names(x[[1]])
    objNames<-as.character(object)
    if(any(duplicated(objNames))) objNames <- paste(objNames,1:n,sep="")
    tmp <- as.character(x[[1]])
    for(i in 2:n){
        match.names(snames,names(x[[i]]))
        nr[i] <- sum(attr(x[[i]], "weight"))
        tmp <- cbind(tmp, as.character(x[[i]]))
    }
    if (type == "DNA") 
        dat <- phyDat.DNA(tmp, return.index = TRUE)
    if (type == "AA") 
        dat <- phyDat.AA(tmp, return.index = TRUE)
    if (type == "User") 
        dat <- phyDat.default(tmp, type = "USER", levels = levels, 
            return.index = TRUE)
    attr(dat,"index") <- cbind(index=attr(dat,"index"), genes=rep(objNames, each=nr))   
    dat
}


baseFreq <- function(dat){
    if (class(dat) != "phyDat") 
        stop("data must be of class phyDat")
    levels <- attr(dat,"levels")
    weight <- attr(dat,"weight")	
    n <- length(dat)	
    res <- numeric(length(levels)) 	
    for(i in 1:n)res <- res+colSums(dat[[i]]*weight)	
    res <- res/sum(res)
    names(res) <- levels	
    res	
}


phylo <- function(edge, tip, edge.length=NULL){
    res <- list(edge=edge, tip.label=tip, edge.length=edge.length)
	class(res)="phylo"
	res
	}

	
getCols <- function (data, cols) 
{
    attrib = attributes(data)
    attr(data, "class") <- "list"
    data = data[cols]
    if (is.character(cols)) 
        attrib$names = cols
    else attrib$names = attrib$names[cols]
    attributes(data) = attrib
    attr(data, "class") <- "phyDat" 
    data
}


getRows <- function (data, rows) 
{    
    for (i in 1:length(data)) data[[i]] = as.matrix(data[[i]])[rows, ]
    attr(data, "weight") = attr(data, "weight")[rows]
    attr(data, "nr") = length(rows)
    data
}
	

allSitePattern <- function(n,levels=c("a","c","g","t"), names=NULL){
	l=length(levels)
	X=matrix(0, l^n,n)
	for(i in 1:n)
	X[, i] = rep(rep(c(1:l), each=l^(i-1)),l^(n-i))
	for(i in 1:l)X[X==i] = levels[i]
	if(is.null(names))colnames(X) = paste("t",1:n, sep="")
	else colnames(X)=names
	phyDat.default(t(X), levels)
}	

	
write.phylip <- function(data, weight, file=""){
        n = sum(weight)
        m = dim(data)[2]
        cat(m,n,"\n",file = file)
        for(i in 1:m)
        cat(colnames(data)[i],"   ",toupper(rep(data[,i],weight)),"\n", sep="", file=file, append=TRUE)
}
	


read.aa <- function (file, format = "interleaved", skip = 0, nlines = 0, 
    comment.char = "#", seq.names = NULL) 
{
    getTaxaNames <- function(x) {
        x <- sub("^ +", "", x)
        x <- sub(" +$", "", x)
        x <- sub("^['\"]", "", x)
        x <- sub("['\"]$", "", x)
        x
    }
    format <- match.arg(format, c("interleaved", "sequential", "fasta"))
    phylip <- if (format %in% c("interleaved", "sequential")) 
        TRUE
    else FALSE
    X <- scan(file = file, what = character(), sep = "\n", quiet = TRUE, 
        skip = skip, nlines = nlines, comment.char = comment.char)      
           
    if (phylip) {
        fl <- X[1]
        oop <- options(warn = -1)
        fl.num <- as.numeric(unlist(strsplit(gsub("^ +", "", fl), " +")))
        options(oop)
        if (all(is.na(fl.num))) 
            stop("the first line of the file must contain the dimensions of the data")
        if (length(fl.num) != 2) 
            stop("the first line of the file must contain TWO numbers")
        else {
            n <- fl.num[1]
            s <- fl.num[2]
        }
        X <- X[-1]
        obj <- vector("character", n * s)
        dim(obj) <- c(n, s)
    }
    if (format == "interleaved") {
        fl <- X[1]
        fl <- unlist(strsplit(fl, NULL))
        bases <- grep("[-AaRrNnDdCcQqEeGgHhIiLlKkMmFfPpSsTtWwYyVvBbZzXx?]", fl)        
        z <- diff(bases)
        for (i in 1:length(z)) if (all(z[i:(i + 8)] == 1)) 
            break
        start.seq <- bases[i]
        if (is.null(seq.names)) 
            seq.names <- getTaxaNames(substr(X[1:n], 1, start.seq - 1))
        X[1:n] <- substr(X[1:n], start.seq, nchar(X[1:n]))
        X <- gsub(" ", "", X)
        nl <- length(X)
        for (i in 1:n) obj[i, ] <- unlist(strsplit(X[seq(i, nl, n)], NULL))
    }
    if (format == "sequential") {
        fl <- X[1]
        taxa <- character(n)
        j <- 1
        for (i in 1:n) {
            bases <- grep("[-AaRrNnDdCcQqEeGgHhIiLlKkMmFfPpSsTtWwYyVvBbZzXx?]", 
                unlist(strsplit(X[j], NULL)))
            z <- diff(bases)
            for (k in 1:length(z)) if (all(z[k:(k + 8)] == 1)) 
                break
            start.seq <- bases[k]
            taxa[i] <- substr(X[j], 1, start.seq - 1)
            sequ <- substr(X[j], start.seq, nchar(X[j]))
            sequ <- gsub(" ", "", sequ)
            j <- j + 1
            while (nchar(sequ) < s) {
                sequ <- paste(sequ, gsub(" ", "", X[j]), sep = "")
                j <- j + 1
            }
            obj[i, ] <- unlist(strsplit(sequ, NULL))
        }
        if (is.null(seq.names)) 
            seq.names <- getTaxaNames(taxa)
    }
    if (format == "fasta") {
        start <- grep("^ {0,}>", X)
        taxa <- X[start]
        n <- length(taxa)
        obj <- vector("list", n)
        if (is.null(seq.names)) {
            taxa <- sub("^ {0,}>", "", taxa)
            seq.names <- getTaxaNames(taxa)
        }
        start <- c(start, length(X) + 1)
        for (i in 1:n) obj[[i]] <- unlist(strsplit(gsub(" ", 
            "", X[(start[i] + 1):(start[i + 1] - 1)]), NULL))
    }
    if (phylip) {
        rownames(obj) <- seq.names
        obj <- tolower(obj)
    }
    else {
        names(obj) <- seq.names
        obj <- lapply(obj, tolower)
    }
    obj   
}
		

#
# tree manipulation
#	 
		
phyloNode <- function(root, pvector, cvector, evector, tip, tips, Nnode){
	res <- list(root=root, pvector=pvector, cvector=cvector, evector=evector, tip=tip, tips=tips, Nnode=Nnode)
	class(res)="phyloNode"
	res
	}
	


add.tip <- function(phy, n, edgeLength=NULL, tip=""){ 
     ind <- which(phy$edge[,2] == n)
     phy <- new2old.phylo(phy) 
     edge <- matrix(as.numeric(phy$edge),ncol=2)
     k <- min(edge)
     l <- max(edge)
     phy$edge <- rbind(phy$edge, c(k-1,phy$edge[ind,2]))
     phy$edge <- rbind(phy$edge, c(k-1,l+1))
     phy$edge[ind,2] = k-1 
     phy$edge.length[ind] = edgeLength[1]
     phy$edge.length <- c(phy$edge.length, edgeLength[-1])
     phy$tip.label <- c(phy$tip.label, tip) 
     phy <- old2new.phylo(phy)
     phy <- as.phylo.phyloNode(as.phyloNode.phylo(phy))
     phy
}



as.phyloNode.phylo <- function (x, ...) {
    parents <- x$edge[, 1]
    child <- x$edge[, 2]
    root <- unique(parents[is.na(match(parents,child))])
    if(length(root)>2) stop("more than 1 root found")
    pvector <- numeric(max(parents))
    pvector[child] <- parents
    tips <- !logical(max(parents))
    tips[parents] <- FALSE
    cvector <- vector("list", max(parents))
    for (i in 1:length(parents)) cvector[[parents[i]]] <- c(cvector[[parents[i]]], 
        child[i])
    evector <- NULL
    if (!is.null(x$edge.length)) {
        evector <- numeric(max(parents))
        evector[child] <- x$edge.length
    }
    list(root = root, pvector = pvector, cvector = cvector, evector = evector, 
        tip = x$tip.label, tips = tips, Nnode = x$Nnode)
}

 
as.phylo <- function (x, ...) UseMethod("as.phylo")
as.phyloNode <- function (x, ...) UseMethod("as.phyloNode")

as.phylo.phyloNode <- function(x, order="pruningwise", ...){
	if(order=="pruningwise")result <- phyloPruning(x)
	if(order=="cladewise")result <- phyloClade(x)
	result
}


phyloClade <- function(phyloNode, root=NULL){
    edge <- NULL
    if(is.null(root))root <- phyloNode$root
    tips <- phyloNode$tips
    cvector <- phyloNode$cvector
    pvector <- phyloNode$pvector
    mylist <- cvector[[root]]
    edge.length <- NULL
    while(length(mylist)){
        kid = mylist[1]
    	edge <- rbind(edge, cbind(pvector[kid],kid))
    	if(!is.null(phyloNode$evector)) edge.length <- c(edge.length, phyloNode$evector[kid])
        if(!tips[kid]) mylist <- c(cvector[[kid]], mylist[-1])     
        else mylist <- mylist[-1]  
        }
    tip.label = phyloNode$tip   
    tree <- list(edge=edge, edge.length=edge.length, tip.label=tip.label, Nnode= length(unique(edge[,1]))) # phyloNode$Nnode)
    class(tree) <- "phylo" 
    attr(tree, "order") <- "cladewise"
    tree
}


phyloPruning <- function (phyloNode, root=NULL) 
{
    edge <- NULL
    if(is.null(root))root <- phyloNode$root
    tips <- phyloNode$tips
    cvector <- phyloNode$cvector
    parent.list <- root
    edge.length <- NULL
    while (length(parent.list)) {
        parent <- parent.list[1]
        kids <- cvector[[parent]]
        edge <- rbind(cbind(parent, kids), edge)
        if (!is.null(phyloNode$evector)) 
            edge.length <- c(phyloNode$evector[kids], edge.length)
        parent.list = c(parent.list[-1], kids[which(!tips[kids])])
    }
    tip.label = phyloNode$tip 
    tree <- list(edge = edge, edge.length = edge.length, tip.label = tip.label, 
        Nnode = length(unique(edge[,1]))) 
    class(tree) <- "phylo"
    attr(tree, "order") <- "pruningwise"
    tree
}


nnin <- function (tree, n) 
{
	tree = reorder(tree)
    tree1 = tree
    tree2 = tree
    edge = matrix(tree$edge, ncol = 2)
    parent = edge[, 1]
    child = tree$edge[, 2]
    k = min(parent) - 1
    ind = which(child > k)[n]
    p1 = parent[ind]
    p2 = child[ind]
    ind1 = which(parent == p1)
    ind1 = ind1[ind1 != ind][1]
    ind2 = which(parent == p2)
    e1 = child[ind1]
    e2 = child[ind2[1]]
    e3 = child[ind2[2]]
    tree1$edge[ind1, 2] = e2
    tree1$edge[ind2[1], 2] = e1
    tree2$edge[ind1, 2] = e3
    tree2$edge[ind2[2], 2] = e1
    tree1 <- as.phylo.phyloNode(as.phyloNode.phylo(tree1))
    tree2 <- as.phylo.phyloNode(as.phyloNode.phylo(tree2))
    result = list(tree1, tree2)
    result
} 


nni <- function (tree, edge.length = FALSE)
{
    k = min(tree$edge[, 1]) - 1
    n = sum(tree$edge[, 2] > k)
    result = list()
    for (i in 1:n) result = c(result, nnin(tree, i))
    class(result) <- "multiPhylo"
    result
}



allTrees <- function(n, rooted = FALSE, tip.label = NULL) {
# A function to generate all possible binary trees (rooted or
# unrooted) for a given number of taxa (up to 10).

	# Initialise variables, starting with the edge matrix for the one
	# and only three-taxon unrooted tree, or for the two-taxon rooted
	# tree, as necessary.
	if (rooted) {
	    edge <- matrix(NA, 2, 2)
		edge[] <- c(3, 3, 1, 2)
	} else {
	    edge <- matrix(NA, 3, 2)
		edge[] <- c(4, 4, 4, 1, 2, 3)
	}
	edges <- list()
	edges[[1]] <- edge
	trees <- list()

	# Die if the user tries to make stupid numbers of trees.
	if ((n+rooted) > 10) {
		nt <- dfactorial(2*(n+rooted)-5)
		stop("That would generate ", round(nt), " trees, and take up more than ", round(nt/1000), " MB of memory!")
	}

	if (n < 2) {
		stop("A tree must have at least two taxa.")
	}
	if (!rooted && n == 2) {
		stop("An unrooted tree must have at least three taxa.")
	}

	if ((n+rooted) > 3) {

		# Build the tree recursively, adding one taxon at a time, 
		# starting with taxon 3 if rooted, 4 if not.
		for (i in (3+!rooted):n) {

			# Take each of the existing edge matrices.
			m <- length(edges)
			newedges <- list()
			for (j in 1:m) {
				edge <- edges[[j]]
				l <- nrow(edge)

				# Take one edge at a time and split it, adding the
				# new taxon (i).
				for (k in 1:l) {
					edge <- edges[[j]]
					# First we need to renumber the internal nodes.
					for (z in (2*i-4+rooted):i) {
						edge[] <- as.integer(sub(z, z+1, edge))
					}
					node <- edge[k,1]
					edge[k,1] <- 2*i-2+rooted
					new1 <- c(2*i-2+rooted, i)
					new2 <- c(node, 2*i-2+rooted)
					edge <- rbind(edge, new1, new2)
					dim(edge) <- c(l+2, 2)
					newedges[[(j-1)*(l+rooted)+k]] <- edge
				}

				if (rooted) {
					# Add the new taxon as outgroup as well.
					edge <- edges[[j]]
					for (z in 2*i-3:i) {
						edge <- sub(z, z+2, edge)
					}
					edge <- as.integer(edge)
					dim(edge) <- c(l, 2)
					new1 <- c(i+1, i)
					new2 <- c(i+1, i+2)
					edge <- rbind(new2, edge, new1)
					dim(edge) <- c(l+2, 2)
					newedges[[j*(l+1)]] <- edge
				}
			}

			# Take the new set of edge matrices.
			edges <- newedges
		}
	}

	# Take each of the edge length matrices and add tip labels and so
	# forth to turn it into a tree.
	m <- length(edges)
	for (x in 1:m) {
		trees[[x]] <- list(edge = edges[[x]])
		trees[[x]]$tip.label <- if (is.null(tip.label)) 
			paste("t", 1:n, sep = "")
		else tip.label
		trees[[x]]$Nnode <- n - 2 + rooted
		class(trees[[x]]) <- "phylo"

		# Reorder the trees cladewise, because otherwise some of them
		# will, for some arcane reason, crash R when it tries to
		# reorder them pruningwise.
#		trees[[x]] <- reorder(trees[[x]], "cladewise")
		
		trees[[x]] <- as.phylo.phyloNode(as.phyloNode.phylo(trees[[x]]))
	}
	class(trees) <- "multiPhylo"
	trees
}


#
# Maximum Parsimony 
# 

 
sankoff.quartet <- function (dat, cost, p, l, weight) 
{
    tmp <- .Call("sankoffQuartet", sdat = dat, sn = p, scost = cost, 
        sk = l, PACKAGE = "phangorn")
    erg <- .Call("rowMin", tmp, as.integer(p), as.integer(l), PACKAGE = "phangorn")
    sum(weight * erg)
}

 
sankoffNNI <- function (tree, n, datp, datf, p, l, p0, cost, weight) 
{
    edge = matrix(tree$edge, ncol = 2)
    parent = edge[, 1]
    child = tree$edge[, 2]
    k = min(parent) - 1
    nTips = min(parent) - 1
    ind = which(child > nTips)[n]
    p1 = parent[ind]
    p2 = child[ind]
    ind1 = which(parent == p1)
    ind1 = ind1[ind1 != ind]
    ind1 = c(which(child == p1), ind1)
    ind2 = which(parent == p2)
    e1 = child[ind1[1]]
    if (p1 > k + 1) 
        e1 = parent[ind1[1]]
    e2 = child[ind1[2]]
    e3 = child[ind2[1]]
    e4 = child[ind2[2]]
    datn = vector("list", 4)
    attr(datn, "dim") = c(1, 4)
    if (p1 == k + 1) 
        datn[[1]] = datf[[e1]]
    if (p1 > k + 1) 
        datn[[1]] = datp[[p1]]
    datn[[2]] = datf[[e2]]
    datn[[3]] = datf[[e3]]
    datn[[4]] = datf[[e4]]
    new1 <- sankoff.quartet(datn[, c(1, 3, 2, 4), drop=FALSE], cost, p, l, weight)
    new2 <- sankoff.quartet(datn[, c(1, 4, 3, 2), drop=FALSE], cost, p, l, weight)
    res = c(p0, new1, new2)
    wm = which.min(res)
    edgeID = NULL
    swap = FALSE
    if (wm > 1) {
        swap = TRUE
        edgeID = c(ind1, ind2, ind)
    }
    list(res = res, edgeID = edgeID, swap = swap, wm = wm)
}


parsimony <- function(tree, data, method='sankoff',...){
    if(is.rooted(tree))tree <- unroot(tree)
    if(is.null(attr(tree,"order")) || attr(tree,"order")=="cladewise")tree <- reorder(tree, "pruningwise")  
    if(method=='sankoff') result <- sankoff(tree,data,...)
    if(method=='fitch') result <- fitch(tree,data)
    result 
}


fitch <- function (tree, data) 
{
    if (class(data) != "phyDat") 
        stop("data must be of class phyDat")
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "pruningwise")
    levels <- attr(data, "levels")
    l = length(levels)
    weight = attr(data, "weight")
    p = attr(data, "nr")
    q = length(data)
    data <- prepareDataFitch(data)
    d = attributes(data)
    data <- as.integer(data)
    attributes(data) <-d

    node <- tree$edge[, 1]
    edge <- tree$edge[, 2]
    m = length(edge) + 1
    dat = integer(m * p)
    attr(dat, "dim") <- c(m, p)
    dat[1:q, ] = data[tree$tip.label, ]
    pars <- integer(p)
    result <- .C("fitch3", dat, as.integer(p), as.integer(m), 
        as.integer(pars), as.integer(node), as.integer(edge), 
        as.integer(length(edge)), PACKAGE="phangorn")
    sum(weight * result[[4]])
}


prepareDataFitch <- function(data){
    lev <- attr(data,"levels")
    l <- length(lev)
    nr <- attr(data,"nr")  
    X <- matrix(ncol=nr, nrow=length(data))
    for(i in 1:length(data)) X[i,] = data[[i]] %*% 2^c(0:(l-1))
    attrData <- attributes(data)
    nam <- attrData$names
    attrData$names <- NULL
    X <- as.integer(X)
    attributes(X) <- attrData 
    attr(X, "dim") <- c(length(data), nr)
    dimnames(X) <- list(nam,NULL)
    X
}


prepareDataSankoff <- function(data){
    tf = function(dat) {
        dat[dat == 0] = 1e+06
        dat[dat == 1] <- 0
        dat
    }   
    attrData <- attributes(data)
    data <- lapply(data, tf)
    attributes(data) <- attrData 
    data
}


sankoff <- function (tree, data, cost = NULL) 
{
    if (class(data) != "phyDat") 
        stop("data must be of class phyDat")
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "p")
    data <- prepareDataSankoff(data)

    levels <- attr(data, "levels")
    l = length(levels)  

    if (is.null(cost)) {
        cost <- matrix(1, l, l)
        cost <- cost - diag(l)
    }   
    for (i in 1:length(data)) storage.mode(data[[i]]) = "double"
    fit.sankoff(tree, data, cost, FALSE)
}


fit.sankoff <- function (tree, data, cost, returnData = FALSE) 
{
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "p")
    node <- tree$edge[, 1]
    edge <- tree$edge[, 2]
    weight = attr(data, "weight")
    p = attr(data, "nr")
    q = length(tree$tip.label)
    l = attr(data, "nc")
    m = length(edge) + 1
    dat = vector(mode = "list", length = m)
    dat[1:q] = data[tree$tip.label]
    nr = as.integer(dim(dat[[1]])[1])
    nc = as.integer(dim(dat[[1]])[2])
    node = as.integer(node - 1)
    edge = as.integer(edge - 1)
    nTips = as.integer(length(tree$tip))
    mNodes = as.integer(max(node) + 1)
    tips = as.integer((1:length(tree$tip))-1)
    res <- .Call("sankoff3", dat, as.numeric(cost), as.integer(nr),as.integer(nc),
         node, edge, mNodes, tips, PACKAGE="phangorn")  
    root <- node[length(node)] + 1
    erg <- .Call("rowMin", res[[root]], as.integer(p), as.integer(l), PACKAGE = "phangorn")
    pscore <- sum(weight * erg)
    result = pscore
    if (returnData) 
        result <- list(pscore = pscore, dat = res)
    result
}



pnodes <- function (tree, dat, cost, external = TRUE) 
{
    dl = dim(dat[[1]])[2]
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "p")
    l = length(dat)
    parent <- tree$edge[, 1]
    child <- tree$edge[, 2]
    datp = vector("list", l)
    pl = length(parent) + 1
    p = dim(dat[[1]])[1]
    pj = parent[pl - 1]
    start = pl - 1
    tmp = dat[[1]] * 0
    datp[[pj]] = tmp
    nTips = min(parent) - 1
    for (j in (pl - 1):1) {
#        blub = TRUE
#        isParent = (child[j] > nTips)
#        if (!external & !isParent) 
#            blub = FALSE
#        if (blub) {
            res <- .Call("sankoff2", sdat = datp[[parent[j]]], 
                sn = p, scost = cost, sk = dl, PACKAGE = "phangorn")
            if (pj != parent[j]) {
                pj = parent[j]
                start = j
            }
            i = start
            while (i > 0 && pj == parent[i]) {
                if (i != j) 
                  res <- res + .Call("sankoff2", sdat = dat[[child[i]]], 
                    sn = p, scost = cost, sk = dl, PACKAGE = "phangorn")
                i = i - 1
            }
            datp[[child[j]]] = res
#        }
    }
    datp
}


sankoff.nni <- function (tree, data, cost, ...) 
{
    nnimove2 <- function(tree, id, first) {
        child = tree$edge[, 2]
        if (first) {
            tree$edge[id[2], 2] = child[id[3]]
            tree$edge[id[3], 2] = child[id[2]]
        }
        if (!first) {
            tree$edge[id[2], 2] = child[id[4]]
            tree$edge[id[4], 2] = child[id[2]]
        }
        tree
    }
    if (class(data) != "phyDat") 
        stop("data must be of class phyDat")
    levels <- attr(data, "levels")
    l = length(levels)
    weight = attr(data, "weight")
    p = attr(data, "nr")
    kl = TRUE
    i = 1
    tmp = fit.sankoff(tree, data, cost, TRUE)
    p0 = tmp[[1]]
    datf = tmp[[2]]
    datp = pnodes(tree, datf, cost, FALSE)
    swap = 0
    result = NULL
    indM = NULL
    ll = NULL
    ind = NULL
    id <- NULL
    wm <- NULL
    tmp = numeric(length(tree$edge[, 1]))
    while (kl) {
        res = sankoffNNI(tree, n = i, datp = datp, datf = datf, 
            p, l, p0, cost, weight)
        result = rbind(result, res[[1]])
        if (res$swap) {
            swap = TRUE
            tmp2 = tmp
            tmp2[res$edgeID] = 1
            indM = rbind(indM, tmp2)
            ll = c(ll, res$res[res$wm])
            id = rbind(id, res$edgeID)
            wm = c(wm, res$wm)
        }
        if (i == (tree$Nnode - 1)) 
            kl = FALSE
        i = i + 1
    }
    if (swap) {
        l = length(ll)
        INDEX = matrix(0, l, length(tree$edge[, 1]))
        for (i in 1:length(ll)) INDEX[i, id[i, ]] = 1
        ind = which.min(ll)
        rll = rank(ll, ties.method = "random")
        tmp = which(tcrossprod(INDEX)[, ind] == 0)
        while (length(tmp) > 0) {
            st = tmp[which.min(rll[tmp])]
            INDEX[ind[1], ] = INDEX[ind[1], ] + INDEX[st, ]
            ind = c(ind, st)
            tmp = which(tcrossprod(INDEX)[, ind[1]] == 0)
        }
        swap = 0
        for (i in ind) {
            tree2 <- nnimove2(tree, id[i, ], wm[i] == 2)
            tree3 <- as.phylo.phyloNode(as.phyloNode.phylo(tree2))
            p1 = fit.sankoff(tree3, data, cost)
            if (p1 < p0) {
                swap = swap + 1
                tree = tree2
                p0 = p1
            }
        }
        cat(swap, "\n")
        tree <- as.phylo.phyloNode(as.phyloNode.phylo(tree))
    }
    list(tree = tree, pscore = p0, swap = swap)
}


optim.parsimony <- function(tree,data,cost=NULL,...) {
    if(is.rooted(tree))tree <- unroot(tree)
    if(is.null(attr(tree,"order")) || attr(tree,"order")=="cladewise")tree <- reorder(tree, "pruningwise")
    
    dat <- prepareDataSankoff(data)
    l <- attr(dat, "nc")
    if (is.null(cost)) {
        cost <- matrix(1, l, l)
        cost <- cost - diag(l)
    }
    tree$edge.length=NULL
            swap = 0
            iter = TRUE
            pscore <- fit.sankoff(tree,dat,cost)
            while (iter) {
                res <- sankoff.nni(tree,dat,cost,...)
                tree <- res$tree
                cat("optimize topology: ", pscore , "-->", res$pscore, 
                  "\n")
                pscore = res$pscore
                swap = swap + res$swap
                if (res$swap == 0) iter = FALSE
            }
            cat("Final p-score",pscore,"after ",swap, "nni operations \n") 
            list(tree=tree,pscore=pscore)          
}


#
# Maximum likelihood estimation
#



discrete.gamma <- function (alpha, k) 
{
    if (k == 1) return(1)
    quants <- qgamma((1:(k - 1))/k, shape = alpha, rate = alpha)
    diff( c(0, pgamma(quants * alpha, alpha + 1),1)) * k
}


optimQ = function(tree, data, Q=c(1,1,1,1,1,1), trace=0,...){
	l = length(Q)
	Q = Q[-l]
	Q = sqrt(Q)
	fn = function(Q,tree,data,...){
	  pml2(tree, data, Q=c(Q^2,1),...)
	}
	res = optim(par=Q, fn=fn, gr=NULL, method = "L-BFGS-B", lower=0, upper=Inf, control=list(fnscale=-1, maxit=25, trace=trace),tree=tree, data=data,...)
	res[[1]] = c(res[[1]]^2,1)	
	res
	}	
		
    
optimGamma = function(tree, data, shape=1, k=4,...){
	fn = function(shape, tree, data, k,...)pml2(tree, data, shape=shape, k=k,...)
	res = optimize(f=fn, interval = c(0,100), lower = 0, upper = 100, maximum = TRUE,
		 tol = .01, tree=tree, data=data, k=k,...)
	res
	}
    
 
optimInv = function(tree, data, inv=0.01, INV=NULL, ll.0=NULL,...){
	fn = function(inv, tree, data,...)pml2(tree, data, inv=inv, INV=INV, ll.0=NULL,...)
	res = optimize(f=fn, interval = c(0,1), lower = 0, upper = 1, maximum = TRUE,
		 tol = .0001, tree=tree, data=data,...)
	res
	}
  

optimRate <- function(tree, data, rate=1, ...){
    fn <- function(rate, tree, data, ...) pml2(tree, data, rate=rate, ...)
    res <- optimize(f = fn, interval = c(0, 100), tree = tree, data = data, ..., 
        lower = 0, upper = 100, maximum = TRUE, tol = 0.01)
    res
}		
	

optimBf = function(tree, data, bf=c(.25,.25,.25,.25), trace=0,...){
	l=length(bf)
	nenner = 1/bf[l]
	lbf = log(bf * nenner)
	lbf = lbf[-l]
	fn = function(lbf, tree, data,...){
		bf = exp(c(lbf,0))
		bf = bf/sum(bf)
		pml2(tree, data, bf=bf, ...)
		}
	res = optim(par=lbf, fn=fn, gr=NULL, method="Nelder-Mead", control=list(fnscale=-1, maxit=500, trace=trace),tree=tree, data=data,...)
	bf = exp(c(res[[1]],0))
	bf = bf/sum(bf)
	result = list(bf=bf, loglik = res[[2]])
	result
	}	
	
	

optimW = function(fit,...){
	w = fit$w
	g = fit$g
	siteLik = fit$siteLik
	k = length(w)
	l = dim(siteLik[[1]])[1]
	x=matrix(0,l,k)
	for(i in 1:k)x[,i] = rowSums(siteLik[[i]])
	weight = fit$weight
	nenner = 1/w[k]
	eta = log(w * nenner)
	eta = eta[-k]
	fn = function(eta,x,g,weight){
		eta = c(eta,0)
		p = exp(eta)/sum(exp(eta))
		res = x%*%p
		res = sum(weight*log(res))  * (1 + abs(sum(p*g) - 1))
		res
	}  
	res = optim(eta, fn = fn, method = "Nelder-Mead", control=list(fnscale=-1, reltol = 1e-12),gr=NULL, x=x,g=g, weight=weight)
	p = exp(c(res$par,0))
	p = p/sum(p)
	result = list(par = p, value = res$value)
	result	
}


#predict.pml <- function(object, newdata,...) sum(object$site * newdata)


logLik.pml <- function(object,...){
	res <- object$logLik
	attr(res,"df") <- object$df
	class(res) <- "logLik"
	res
}

	
	
vcov.pml <- function(object, obs=FALSE,...){
	if(obs) FI = score4(object)[[2]]
	else FI = score(object,FALSE)[[2]]
	l = dim(FI)[1]
	res = try(solve(FI))
	if(class(res) == "try-error"){
	    cat("Covariance is ill-conditioned !! \n")
		res = solve(FI + diag(l)* 1e-8)
		}
	res
}
		


getd2P <- function(el, eig=edQt(), g=1.0){
	n <- length(eig$values)	
	res <- .Call("getd2PM",eig,as.integer(n),as.double(el),as.double(g), PACKAGE = "phangorn")
    attr(res,"dim") <- c(length(g),length(el))
	res
}	
	
getdP <- function(el, eig=edQt(), g=1.0){
	n <- length(eig$values)	
	res <- .Call("getdPM",eig,as.integer(n),as.double(el),as.double(g), PACKAGE = "phangorn")
    attr(res,"dim") <- c(length(g),length(el))
	res
}


# version without transformation 
getdP2 <- function(el, eig=edQt(), g=1.0){
	n <- length(eig$values)	
	res <- .Call("getdPM2",eig,as.integer(n),as.double(el),as.double(g), PACKAGE = "phangorn")
    attr(res,"dim") <- c(length(g),length(el))
	res
}


# version without transformation 
getd2P2 <- function(el, eig=edQt(), g=1.0){
	n <- length(eig$values)	
	res <- .Call("getd2PM2",eig,as.integer(n),as.double(el),as.double(g), PACKAGE = "phangorn")
    attr(res,"dim") <- c(length(g),length(el))
	res
}


getP <- function(el, eig=edQt(), g=1.0){
	n <- length(eig$values)	
	res <- .Call("getPM",eig,as.integer(n),as.double(el),as.double(g), PACKAGE = "phangorn")
	attr(res,"dim") <- c(length(g),length(el))
	res
}




lli <- function (data, tree, ...) 
{
    nr = attr(data, "nr")
    nc = attr(data, "nc")
    dat = data[tree$tip.label]
    m = length(dat)
    res <- matrix(1, nr, nc)
    for (i in 1:m) res = res * dat[[i]]
    res
}


edQt <- function (Q = c(1, 1, 1, 1, 1, 1), bf = c(0.25, 0.25, 0.25, 0.25)) 
{
    l = length(bf)
    res = matrix(0, l, l)
    res[lower.tri(res)] = Q
    res = res + t(res)
    res = res * bf
    res2 = res * rep(bf, each = l)    
    diag(res) = -colSums(res)
    res = res/sum(res2)
    e = eigen(res, FALSE)
    e$inv = solve(e$vec)
    e
}


edQ <- function(Q=c(1,1,1,1,1,1), bf=c(0.25,.25,.25,.25)){
	l=length(bf)
    res = matrix(0, l, l)
	res[lower.tri(res)] = Q
	res = res+t(res)
	res = res * rep(bf,each=l)
	diag(res) = -rowSums(res)
	res2 = res * rep(bf,l)
	diag(res2)=0 
	res = res/sum(res2)
	e = eigen(res, FALSE)
	e$inv = solve(e$vec)
	e
}



pml3 <- function (object,...) 
{
	tree = object$tree
    Q = object$Q
    bf = object$bf
    eig = object$eig
    w = object$w
    g = object$g
    data = object$data
    ll0 <- object$logLik
    ll.0 <- object$ll.0
    weight = attr(data, "weight")
    lll = ll.0
    m = 1
    p = length(g)
    q = length(tree$edge[, 1]) + 1
    resll = vector("list", p)
    while (m <= p) {
        res = ll(data, tree, bf = bf, g = g[m], Q = Q, eig = eig, 
            assign.dat = FALSE, ...)
        resll[[m]] <- res
        m = m + 1
    }
    for (i in 1:p) lll = lll + resll[[i]] * w[i]
    siteLik = log(lll)
    ll0 = sum(weight * siteLik)
    ll0
}


ll <- function (dat1, tree, bf = c(0.25, 0.25, 0.25, 0.25), g = 1, 
    Q = c(1, 1, 1, 1, 1, 1), eig = NULL, assign.dat = FALSE, ...) 
{
	if(is.null(attr(tree,"order")) || attr(tree,"order")=="cladewise")tree <- reorder(tree, "pruningwise")
    q = length(tree$tip.label) 
    node <- tree$edge[, 1]
    edge <- tree$edge[, 2]
    m = length(edge) + 1
    dat = vector(mode = "list", length = m)
    dat[1:q] = dat1[tree$tip.label]
    if (is.null(eig)) eig = edQt(bf = bf, Q = Q)
    el <- tree$edge.length
    P <- getP(el, eig, g)  
    nr <- as.integer(attr(dat1,"nr"))   
    nc <- as.integer(attr(dat1,"nc"))
    node = as.integer(node-min(node))
    edge = as.integer(edge-1)
    nTips = as.integer(length(tree$tip))
    mNodes = as.integer(max(node)+1)
        
    res <- .Call("LogLik", dat[1:q], P, nr, nc, node, edge, nTips, mNodes, PACKAGE = "phangorn")

    result = res[[1]] %*% bf  
    if (assign.dat){
    	dat[(q+1):m] <- res
        attr(dat, "names") = c(tree$tip.label, as.character((q + 1):m))
        assign("asdf", dat, env = parent.frame(n = 1))
        }
    result
}


fs <- function (old.el, eig, parent.dat, child.dat, weight, g=g, 
    w=w, bf=bf, ll.0=ll.0) 
{
    if (old.el < 1e-10) 
        old.el <- 1e-10
    lg = length(parent.dat)
    dad <- vector("list", lg)
    P <- getP(old.el, eig, g)
    for (i in 1:lg) dad[[i]] <- parent.dat[[i]]/(child.dat[[i]] %*% P[[i]])

    f = ll.0
    for (i in 1:lg) f = f + parent.dat[[i]] %*% (w[i] * bf)
    l0 = sum(weight * log(f))

    .Call("FS", eig, as.integer(length(bf)), as.double(old.el), 
            as.double(w), as.double(g), child.dat, dad, as.integer(length(w)), 
            as.integer(length(weight)), as.double(bf), as.double(weight), 
            as.double(ll.0), as.double(l0), as.double(f), PACKAGE="phangorn" )
}


fn.quartet <- function(old.el, eig, bf, dat,  g=1, w=1, weight, ll.0) {
	l= length(dat[,1]) 
    ll = ll.0
    res = vector("list", 2*l)
    tmp1 = NULL
    tmp2 = NULL
    attr(res,"dim") = c(l,2)
    
    for(j in 1:l){
    		P = getP(old.el, eig, g[j])
    		tmp1 = (dat[[j,1]] %*% P[[1]]) *(dat[[j,2]] %*% P[[2]])
    		tmp2 = (dat[[j,3]] %*% P[[3]]) * (dat[[j,4]] %*% P[[4]])
    		res[[j,1]] = tmp1 * (tmp2 %*% P[[5]])
    		res[[j,2]] = tmp2
      		ll = ll +  res[[j,1]] %*% (w[j]*bf)
        } 
 	l0 = sum(weight * log(ll))
 	list(ll=l0,res=res)
}


nnimove <- function(tree, id, el, first){
	child = tree$edge[, 2]
	if(first){
        tree$edge[id[2], 2] = child[id[3]]
        tree$edge[id[3], 2] = child[id[2]]
        tree$edge.length[id] = el
	}
	if(!first){
        tree$edge[id[2], 2] = child[id[4]]
        tree$edge[id[4], 2] = child[id[2]]
        tree$edge.length[id] = el        
	}
	tree
}


pml.nni <- function (fit, ...) 
{
    tree = fit$tree
    kl = TRUE
    i = 1
    .dat <- NULL
    datp = rnodes(fit)
    swap = 0
    result = NULL
    indM = NULL
    ll = NULL
    el = NULL
    ind = NULL
    id <- NULL
    wm <- NULL
    tmp = numeric(length(tree$edge.length))
    while (kl) {
        res = phyloNNI(fit, n = i, datp, datf = .dat)
        result = rbind(result, res[[1]])
        if (res$swap) {
            swap=TRUE
            tmp2 = tmp
            tmp2[res$edgeID] = 1
            indM = rbind(indM, tmp2)
            ll = c(ll, res$res[res$wm])
            el = rbind(el, res$para)
            id = rbind(id, res$edgeID)
            wm = c(wm, res$wm)
        }
        if (i == (tree$Nnode - 1)) 
            kl = FALSE
        i = i + 1
    }
    if(swap) {
        l = length(ll)
        INDEX = matrix(0, l, length(tree$edge.length))
        for (i in 1:length(ll)) INDEX[i, id[i, ]] = 1
        ind = which.max(ll)
        rll = rank(ll, ties.method = "random")
        tmp = which(tcrossprod(INDEX)[, ind] == 0)
        while (length(tmp) > 0) {
            st = tmp[which.max(rll[tmp])]
            INDEX[ind[1], ] = INDEX[ind[1], ] + INDEX[st, ]
            ind = c(ind, st)
            tmp = which(tcrossprod(INDEX)[, ind[1]] == 0)
        }
	    l0=fit$log
	    fit2=fit	
	    swap=0
        for (i in ind){
		tree2 <- nnimove(tree, id[i, ], el[i, ], wm[i] == 2)
		tree3 <- as.phylo.phyloNode(as.phyloNode.phylo(tree2)) 
        fit2$tree = tree3
		l1 = pml3(fit2)
		if(l1 > l0){
			swap = swap+1
			tree=tree2
			l0=l1
			}
		}
        cat(swap," \n")  
        tree <- as.phylo.phyloNode(as.phyloNode.phylo(tree))  
        fit$tree <- tree
        fit <- optimEdge(fit, control = list(eps = 1e-08, maxit = 5))
    }
    fit$swap = swap
    fit
}


rnodes <- function (fit, external = TRUE) 
{
    dat <- NULL
    logLik <- pml5(fit)
    tree = fit$tree
    if (is.null(attr(tree, "order")) || attr(tree, "order") == "cladewise") 
        tree <- reorder(tree, "p")
    eig = fit$eig
    l = dim(dat)[1]
    parent <- tree$edge[, 1]
    child <- tree$edge[, 2]
    nTips = min(parent) - 1
    pl = length(parent) + 1
    datp = vector("list", pl * l)
    attr(datp, "dim") = c(l, pl)
    dat2 = vector("list", pl * l)
    attr(dat2, "dim") = c(l, pl)
    el = tree$edge.length
    gs = fit$g
    datp[, (nTips + 1)] = dat[, (nTips + 1)]
    for (j in (pl - 1):1) {
        blub=TRUE
        isParent = (child[j] > nTips)
        if(!external & !isParent) blub=FALSE 
        if(blub){
            elx = el[j]
            P = getP(elx, eig, gs)
            for (i in 1:l) {
                tmp2 = (datp[[i, parent[j]]]/(dat[[i, child[j]]] %*% P[[i]]))
                dat2[[i, child[j]]] = tmp2
                if (isParent) 
                    datp[[i, child[j]]] = (tmp2 %*% P[[i]]) * dat[[i, child[j]]]
            }
        } 
    }
    assign(".dat", dat, env = parent.frame(n = 1))
    dat2
}



score <- function (fit, transform=TRUE) 
{
    tree = fit$tree
    child <- tree$edge[, 2]
    l = length(child)
    sc = numeric(l)
    weight = as.numeric(fit$weight)
    f <- drop(exp(fit$site))
    dl = dl(fit, transform)
    dl = dl/f
    sc = colSums(weight * dl)
    F = crossprod(dl*weight,dl) 
    names(sc) = child
    dimnames(F) = list(child, child) 
    result = list(sc = sc, F = F)
    result
}


optim.quartet <- function (old.el, eig, bf, dat, g = 1, w = 1, weight, ll.0 = weight * 
    0, control = list(eps = 1e-04, maxit = 5, trace = 0), llcomp=-Inf) 
{
    tmp <- fn.quartet(old.el = old.el, eig = eig, bf = bf, dat = dat, 
        g = g, w = w, weight = weight, ll.0 = ll.0)
    old.ll = tmp$ll
    eps = 1
    iter = 0
    while (eps > control$eps && iter < control$maxit) {
        el1 <- fs(old.el[1], eig, tmp$res[, 1], dat[, 1], weight, 
            g = g, w = w, bf = bf, ll.0 = ll.0)
        el2 <- fs(old.el[2], eig, el1[[2]], dat[, 2], weight, 
            g = g, w = w, bf = bf, ll.0 = ll.0)
        el5 <- fs(old.el[5], eig, el2[[2]], tmp$res[, 2], weight, 
            g = g, w = w, bf = bf, ll.0 = ll.0)
        el3 <- fs(old.el[3], eig, el5[[3]], dat[, 3], weight, 
            g = g, w = w, bf = bf, ll.0 = ll.0)
        el4 <- fs(old.el[4], eig, el3[[2]], dat[, 4], weight, 
            g = g, w = w, bf = bf, ll.0 = ll.0)
        old.el[1] = el1[[1]]
        old.el[2] = el2[[1]]
        old.el[3] = el3[[1]]
        old.el[4] = el4[[1]]
        old.el[5] = el5[[1]]
        iter = iter + 1
        tmp <- fn.quartet(old.el = old.el, eig = eig, bf = bf, 
            dat = dat, g = g, w = w, weight = weight, ll.0 = ll.0)
        ll = tmp[[1]]
        eps = ll - old.ll
        if(ll<llcomp)return(list(old.el, ll))  
        old.ll = ll
    }
    list(old.el, ll)
}


phyloNNI <- function (fit, n, datp, datf) 
{
    tree = fit$tree
    bf = fit$bf
    eig = fit$eig
    k = fit$k
    w = fit$w
    g = fit$g
    edge = matrix(tree$edge, ncol = 2)
    parent = edge[, 1]
    child = tree$edge[, 2]
    k = min(parent) - 1
    ll.0 <- fit$ll.0
    nTips = min(parent) - 1
    ind = which(child > nTips)[n]
    p1 = parent[ind]
    p2 = child[ind]
    ind1 = which(parent == p1)
    ind1 = ind1[ind1 != ind]
    ind1 = c(which(child == p1), ind1)
    ind2 = which(parent == p2)
    e1 = child[ind1[1]]
    e2 = child[ind1[2]]
    e3 = child[ind2[1]]
    e4 = child[ind2[2]]
    el0 = tree$edge.length[c(ind1[1], ind1[2], ind2[1], ind2[2], 
        ind)]
    l = length(datf[, 1])
    weight = fit$weight
    datn = vector("list", 4 * l)
    attr(datn, "dim") = c(l, 4)
    if (p1 <= k + 1) 
        datn[, 1] = datf[, e1]
    if (p1 > k + 1) 
        datn[, 1] = datp[, e1]
    datn[, 2] = datf[, e2]
    datn[, 3] = datf[, e3]
    datn[, 4] = datf[, e4]
    new1 <- optim.quartet(el0[c(1, 3, 2, 4, 5)], eig, bf, 
        datn[, c(1, 3, 2, 4), drop=FALSE], g, w, weight, ll.0, llcomp= fit$log)    
    new2 <- optim.quartet(el0[c(1, 4, 3, 2, 5)], eig, bf,  
        datn[, c(1, 4, 3, 2), drop=FALSE], g, w, weight, ll.0, llcomp= fit$log)    
    res = c(fit$log, new1[[2]], new2[[2]])
    wm = which.max(res)
    edgeID = NULL
    swap = FALSE
    para = NULL
    if (wm > 1) {
        swap = TRUE
        if (wm == 2) 
            para = new1[[1]]
        if (wm == 3) 
            para = new2[[1]]
        edgeID = c(ind1, ind2, ind)
    }
    list(res = res, el = el0, edgeID = edgeID, swap = swap, wm = wm, 
        para = para)
}



plot.pml<-function(x,...)plot.phylo(x$tree,...)




phangornParseFormula <- function(model){

    parseSide <- function(model) {
        model.vars <- list()
        while (length(model) == 3 && model[[1]] == as.name("+")) {
            model.vars <- c(model.vars, model[[3]])
            model <- model[[2]]
        }
        unlist(rev(c(model.vars, model)))

    } 

    if (!inherits(model, "formula")) 
        stop("model must be a formula object")
    l <- length(model)
    varsLHS <- NULL
       
    if(l==3){        
    modelLHS <- model[[2]]
    modelRHS <- model[[3]]
    varsRHS <- parseSide(modelRHS)
    varsRHS <- unlist(lapply(varsRHS,as.character))
    varsLHS <- parseSide(modelLHS)
    varsLHS <- unlist(lapply(varsLHS,as.character))
    }
    if(l==2){
       modelRHS <- model[[2]]
       varsRHS <- parseSide(modelRHS)
       varsRHS <- unlist(lapply(varsRHS,as.character))
    }
    list(left=varsLHS, right=varsRHS)
}



pml.control <- function (epsilon = 1e-06, maxit = 10, trace = FALSE) 
{
    if (!is.numeric(epsilon) || epsilon <= 0) 
        stop("value of 'epsilon' must be > 0")
    if (!is.numeric(maxit) || maxit <= 0) 
        stop("maximum number of iterations must be > 0")
    list(epsilon = epsilon, maxit = maxit, trace = trace)
}


optim.pml <- function (object, optNni = FALSE, optBf = FALSE, optQ = FALSE, 
    optInv = FALSE, optGamma = FALSE, optEdge = TRUE, optRate = FALSE, 
    control = pml.control(maxit = 10, eps = 0.001, trace = TRUE), ...) 
{
    extras <- match.call(expand.dots = FALSE)$...
    pmla <- c("wMix", "llMix")
    wMix <- object$wMix
    llMix <- object$llMix
    if(!is.null(extras)){
    names(extras) <- pmla[pmatch(names(extras), pmla)]
    existing <- match(pmla, names(extras))
    if (!is.na(existing[1])) 
       wMix <- eval(extras[[existing[1]]], parent.frame())
    if (!is.na(existing[2]))
       llMix <- eval(extras[[existing[2]]], parent.frame())
    }
    
    tree = object$tree
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "pruningwise")
    if (optNni) {
        if (!is.binary.tree(tree)) 
            tree = multi2di(tree)
    }
    if (is.rooted(tree)) {
        tree = unroot(tree)
        warning("I unrooted the tree (rooted trees are not yet supported)", 
            call. = FALSE)
    }
    if (optEdge & optRate) {
        warning("you can't optimise edges and rates at the same time, only edges are optimised", 
            call. = FALSE)
        optRate = FALSE
    }
    trace <- control$trace
    Q = object$Q
    bf = object$bf
    eig = object$eig
    inv = object$inv
    k = object$k
    shape = object$shape
    w = object$w
    g = object$g
    dat = object$data
    ll0 <- object$logLik
    INV <- object$INV
    ll.0 <- object$ll.0
    rate <- object$rate
    ll = ll0
    ll1 = ll0
    opti = TRUE
    if (optEdge) {
        object <- optimEdge(object, control = pml.control(eps = 0.001, maxit = 5, trace))
        ll <- object$logLik
        tree <- object$tree
    }
    rounds = 1
    df = 0
    while (opti) {
        if (optBf) {
            res = optimBf(tree, dat, bf = bf, inv = inv, Q = Q, 
                w=w, g=g, INV=INV, rate=rate, k=k, llMix=llMix)
            bf = res[[1]]
            eig = edQt(Q = Q, bf = bf)
            if(inv>0) ll.0 <- INV %*% (bf * inv)
            if(wMix>0) ll.0 <- ll.0 + llMix
            cat("optimize base frequencies: ", ll, "-->", res[[2]], 
                "\n")
            ll = res[[2]]
        }
        if (optQ) {
            res = optimQ(tree, dat, Q=Q, bf=bf, w=w, g=g, 
                inv=inv, INV=INV, ll.0=ll.0, rate=rate, k=k)
            Q = res[[1]]
            eig = edQt(Q = Q, bf = bf)
            cat("optimize rate matrix: ", ll, "-->", res[[2]], "\n")
            ll = res[[2]]
        }
        if (optInv) {
            res = optimInv(tree, dat, inv = inv, INV = INV, Q = Q, 
                bf = bf, eig = eig, k = k, shape = shape, rate = rate)
            inv = res[[1]]
            w = rep(1/k, k)
            g = discrete.gamma(shape, k)
            w = (1 - inv) * w
            if (wMix > 0) w <- (1 - wMix) * w 
            g = g/(1 - inv)
            g <- g * rate
            ll.0 = INV %*% (bf * inv)
            if(wMix>0) ll.0 <- ll.0 + llMix
            cat("optimize invariant sites: ", ll, "-->", res[[2]], 
                "\n")
            ll = res[[2]]
        }
        if (optGamma) {
            res = optimGamma(tree, dat, shape = shape, k = k, 
                inv = inv, INV = INV, Q = Q, bf = bf, eig = eig, 
                ll.0 = ll.0, rate = rate)
            shape = res[[1]]
            w = rep(1/k, k)
            g = discrete.gamma(shape, k)
            if (inv > 0) {
                w = (1 - inv) * w
                g = g/(1 - inv)
            }
            if (wMix > 0) w <- (1 - wMix) * w 
            g <- g * rate
            cat("optimize shape parameter: ", ll, "-->", res[[2]], 
                "\n")
            ll = res[[2]]
        }
        if (optRate) {
            res = optimRate(tree, dat, rate = rate, inv = inv, 
                INV = INV, Q = Q, bf = bf, eig = eig, k = k, 
                shape = shape, w = w, ll.0 = ll.0)
            rate = res[[1]]
            # w = rep(1/k, k)
            g = discrete.gamma(shape, k)
            w = rep(1/k, k) 
            if (inv > 0) {
                w = (1 - inv) * w
                g = g/(1 - inv)
            }
            if (wMix > 0) w <- (1 - wMix) * w 
            g <- g * rate
            cat("optimize rate: ", ll, "-->", res[[2]], "\n")
            ll = res[[2]]
        }
        if (optEdge) {
           object <-update.pml(object, tree=tree, dat=dat, Q=Q, bf=bf,
                 inv=inv, shape=shape, k=k, rate=rate, wMix=wMix, llMix=llMix)
            object <- optimEdge(object, control = list(eps = 0.001, 
                maxit = 5))
            ll <- object$logLik
            tree <- object$tree
        }
        if (optNni) {
            swap = 0
            iter = 1
            while (iter < 4) {
                tree <- object$tree
                object <- pml.nni(object)
                tree <- object$tree
                cat("optimize topology: ", ll, "-->", object$logLik, 
                  "\n")
                ll = object$logLik
                swap = swap + object$swap
                iter = iter + 1
                if (object$swap == 0) {
                  iter = 4
                  optNni = FALSE
                }
            }
            cat(swap, "\n")
            if (swap > 0) 
                rounds = 1
            if (swap == 0) 
                optNni = FALSE
        }
        rounds = rounds + 1
        if (rounds > control$maxit) 
            opti = FALSE
        if (abs(ll1 - ll) < control$eps) 
            opti = FALSE
        ll1 = ll
    }
    df = (optEdge) * length(tree$edge.length) + optGamma * (k - 
        1) + optInv * (inv > 0) + optBf * (length(unique(bf)) - 
        1) + optQ * (length(unique(Q)) - 1)
      object <-update.pml(object, tree=tree, dat=dat, Q=Q, bf=bf,
         inv=inv, shape=shape, k=k, rate=rate, wMix=wMix, llMix=llMix)        
    object$df = df
    object
}



optimEdge <- function (fit, control = list(eps = 1e-08, maxit = 20, trace = 0), 
    ...) 
{
    if (class(fit)[1] != "pml") 
        stop("data must be of class pml")
    tree = fit$tree
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "pruningwise")
    fit$tree <- tree
    el <- tree$edge.length
    tree$edge.length[el < 0] <- 1e-08
    dat <- NULL    
    rate <- fit$rate 
    old.ll <- pml5(fit)
    eig <- fit$eig
    w <- fit$w
    g <- fit$g

    bf <- fit$bf
    weight <- attr(fit$data, "weight")
    ll.0 <- fit$ll.0
    eps = 1
    iter = 0
    child = tree$edge[, 2]
    parent = tree$edge[, 1]
    nTips = min(parent) - 1
    n = length(tree$edge.length)
    while (eps > control$eps && iter < control$maxit) {
        for (j in n:1) {
            child.dat = dat[, child[j]]
            parent.dat = dat[, parent[j]]
            old.el = tree$edge.length[j]
            newEL <- fs(old.el, eig, parent.dat, child.dat, weight, 
                g = g, w = w, bf = bf, ll.0 = ll.0)
            el[j] = newEL[[1]]
            dat[, parent[j]] = newEL[[2]]
            if (child[j] > nTips) {
                dat[, child[j]] = newEL[[3]]
            }
        }
        tree$edge.length = el
        iter = iter + 1
        fit$tree = tree
        dat <- NULL
        newll <- pml5(fit)
        eps = newll - old.ll
        old.ll = newll
    }
    cat(fit$logLik, " -> ", newll, "\n")
    fit$logLik = newll
    fit
}


pml5<-function (object, ...) 
{
    tree = object$tree
    Q = object$Q
    bf = object$bf
    eig = object$eig
    w = object$w
    g = object$g
    data = object$data
    ll0 <- object$logLik
    ll.0 <- object$ll.0
    weight = attr(data, "weight")
    lll = ll.0
    m = 1
    p = length(g)
    q = length(tree$edge[, 1]) + 1
    resll = vector("list", p)
    dat = vector("list", q * p)
    attr(dat, "dim") = c(p, q)
    asdf <- NULL
    while (m <= p) {
        resll[[m]] = ll(data, tree, bf = bf, g = g[m], Q = Q, 
            eig = eig, assign.dat = TRUE, ...)
        dat[m, ] <- asdf
        m = m + 1
    }
    attr(dat, "dimnames") = list(NULL, attr(asdf, "names"))
    for (i in 1:p) lll = lll + resll[[i]] * w[i]
    siteLik <- lll
    siteLik <- log(siteLik)
    ll0 = sum(weight * siteLik)
    assign("dat", dat, env = parent.frame(n = 1))
    ll0
}


#
# pmlPart + pmlCLust
#

optimPartQ <- function (object, Q = c(1, 1, 1, 1, 1, 1), ...) 
{
    l = length(Q)
    Q = Q[-l]
    Q = sqrt(Q)
    fn = function(Q, object, ...) {
        result <- 0
        Q = c(Q^2, 1)
        n <- length(object)
        for (i in 1:n) result <- result + update(object[[i]], 
            Q = Q, ...)$logLik
        result
    }
    res = optim(par = Q, fn = fn, gr = NULL, method = "L-BFGS-B", 
        lower = 0, upper = Inf, control = list(fnscale = -1, 
            maxit = 25), object = object, ...)
    res[[1]] = c(res[[1]]^2, 1)
    res
}


optimPartBf <- function (object, bf = c(0.25, 0.25, 0.25, 0.25), ...) 
{
    l = length(bf)
    nenner = 1/bf[l]
    lbf = log(bf * nenner)
    lbf = lbf[-l]
    fn = function(lbf, object, ...) {
        result <- 0
        bf = exp(c(lbf, 0))
        bf = bf/sum(bf)
        n <- length(object)
        for (i in 1:n) result <- result + update(object[[i]], 
            bf = bf, ...)$logLik
        result
    }
    res = optim(par = lbf, fn = fn, gr = NULL, method = "Nelder-Mead", 
        control = list(fnscale = -1, maxit = 500), object, ...)
    print(res[[2]])
    bf = exp(c(res[[1]], 0))
    bf = bf/sum(bf)
}


optimPartInv <- function (object, inv = 0.01, ...) 
{
    fn = function(inv, object, ...) {
        result <- 0
        n <- length(object)
        for (i in 1:n) result <- result + update(object[[i]], inv = inv, 
            ...)$logLik
        result
    }
    res = optimize(f = fn, interval = c(0, 1), lower = 0, upper = 1, 
        maximum = TRUE, tol = 1e-04, object, ...)
    print(res[[2]])
    res[[1]]
}


optimPartGamma <- function (object, shape = 1, ...) 
{
    fn = function(shape, object, ...) {
        result <- 0
        n <- length(object)
        for (i in 1:n) result <- result + update(object[[i]], shape = shape, 
            ...)$logLik
        result
    }    
    res = optimize(f = fn, interval = c(0, 100), lower = 0, upper = 100, 
        maximum = TRUE, tol = 0.01, object, ...)
    res
}



dl <- function (fit, transform=TRUE) 
{
    tree = fit$tree
    eig = fit$eig
    .dat <- NULL
    datp = rnodes(fit, TRUE)
    m = dim(.dat)[1]
    g = fit$g
    bf = fit$bf
    w = fit$w
    parent <- tree$edge[, 1]
    child <- tree$edge[, 2]
    nTips = min(parent) - 1
    l = length(child)
    sc = numeric(l)
    weight = fit$weight
    dl = matrix(0, length(weight), l)
    ff0 = numeric(length(weight))
    if(transform) dP = getdP(tree$edge.length, eig, g)
    else dP = getdP2(tree$edge.length, eig, g)
    for (i in 1:l) {
        ff = ff0 
        for (j in 1:m) {
            ff = ff + (datp[[j, child[i]]] * (.dat[[j, child[i]]] %*% 
                dP[[j,i]])) %*% (w[j] * bf)
        }
        dl[, i] = ff
    }
    dl
}


optimPartEdge <- function (object, ...) 
{
    tree <- object[[1]]$tree
    theta <- object[[1]]$tree$edge.length
    n <- length(object)
    l <- length(theta)
    nrv <- numeric(n)
     
    for (i in 1:n) nrv[i] = attr(object[[i]]$data, "nr")
    cnr <- cumsum(c(0,nrv))
    weight = numeric(sum(nrv))
    dl <- matrix(NA, sum(nrv), l)
    for (i in 1:n) weight[(cnr[i] +1) :cnr[i+1] ] = attr(object[[i]]$data, "weight")
    ll0 = 0
    for (i in 1:n) ll0 = ll0 + object[[i]]$logLik
    eps = 1
    while (eps > 0.01) {
        for (i in 1:n){
            lv = drop(exp(object[[i]]$site)) 
            dl[(cnr[i] +1) : cnr[i+1], ] = dl(object[[i]], TRUE)/lv
            }
        sc = colSums(weight * dl)
        F = crossprod(dl * weight, dl)
        thetaNew = log(theta) + solve(F, sc)        
        theta = exp(thetaNew)
        tree$edge.length = as.numeric(theta)
        for (i in 1:n) object[[i]] <- update(object[[i]], tree = tree)
        ll1 = 0
        for (i in 1:n) ll1 = ll1 + object[[i]]$logLik
        eps <- ll1 - ll0
        print(ll0)
        ll0 <- ll1
        print(ll1)
    }
    object
}



makePart <- function(fit, weight=~index+genes){
    dat <- fit$data 
    if(class(weight)=="formula")     
        weight <- xtabs(weight, data=attr(dat, "index"))
    fits <- NULL 
    for(i in 1:dim(weight)[2]){ 
       ind <- which(weight[,i] > 0)
       dat2 <- getRows(dat, ind)
       attr(dat2, "weight") <- weight[ind,i]
       fits[[i]] <- update(fit, data = dat2)
    }
    fits
}


pmlPart <- function (formula, object, ...) 
{
    call <- match.call()
    form <- phangornParseFormula(formula)
    opt <- c("nni", "bf", "Q", "inv", "shape", "edge", "rate")
    optAll <- match(opt, form$left)
    optPart <- match(opt, form$right)
    AllBf <- !is.na(optAll[2])
    AllQ <- !is.na(optAll[3])
    AllInv <- !is.na(optAll[4])
    AllGamma <- !is.na(optAll[5])
    AllEdge <- !is.na(optAll[6])
    PartNni <- !is.na(optPart[1])
    PartBf <- !is.na(optPart[2])
    PartQ <- !is.na(optPart[3])
    PartInv <- !is.na(optPart[4])
    PartGamma <- !is.na(optPart[5])
    PartEdge <- !is.na(optPart[6])
    PartRate <- !is.na(optPart[7])
 
    if(class(object)=="pml") fits <- makePart(object, ...)   
    if(class(object)=="pmlPart") fits <- object$fits
    if(class(object)=="list") fits <- object

    p <- length(fits)
    eps = 0
    m = 1
    logLik = 0
    for (i in 1:p) logLik = logLik + fits[[i]]$log
    eps = 10
    while (eps > 0.1 & m < 10) {
        loli = 0
        for (i in 1:p) {
            fits[[i]] = optim.pml(fits[[i]], PartNni, PartBf, 
                PartQ, PartInv, PartGamma, PartEdge, PartRate, 
                control = list(maxit = 3, eps = 0.001))
        }
        if (AllQ) {
            newQ <- optimPartQ(fits)[[1]]
            for (i in 1:p) fits[[i]] <- update(fits[[i]], Q = newQ)
        }
        if (AllBf) {
            newBf <- optimPartBf(fits)
            for (i in 1:p) fits[[i]] <- update(fits[[i]], bf = newBf)
        }
        if (AllInv) {
            newInv <- optimPartInv(fits)
            for (i in 1:p) fits[[i]] <- update(fits[[i]], inv = newInv)
        }
        if (AllGamma) {
            newGamma <- optimPartGamma(fits)[[1]]
            for (i in 1:p) fits[[i]] <- update(fits[[i]], shape = newGamma)
        }
        if (AllEdge) 
            fits <- optimPartEdge(fits)

        loli <- 0
        for (i in 1:p) loli <- loli + fits[[i]]$log
        eps = loli - logLik
        cat("eps: ", eps, "\n")
        logLik <- loli
        m = m + 1
    }
    
    df <- matrix(1, 6 ,2)
    colnames(df) <- c("#df", "group")
    rownames(df) <- c("Edge", "Shape", "Inv", "Bf", "Q", "Rate")
    df[1,1] <- length(fits[[1]]$tree$edge.length)
    df[2,1] <- fits[[1]]$k - 1
    df[3,1] <- fits[[1]]$inv > 0
    df[4,1] <- length(unique(fits[[1]]$bf)) - 1
    df[5,1] <- length(unique(fits[[1]]$Q)) - 1
    df[6,1] <- 0 # rates 
    if(PartEdge) df[1,2] = p
    if(PartGamma) df[2,2] = p
    if(PartInv) df[3,2] = p
    if(PartBf) df[4,2] = p
    if(PartQ) df[5,2] = p
    if(PartRate) df[6,1] = p-1     
    attr(logLik, "df") = sum(df[,1]*df[,2])
    object <- list(logLik = logLik, fits = fits, call = call, df=df)
    class(object) <- "pmlPart" 
    object
}



#
# Distance Matrix methods
#


designTree <- function(tree, method="unrooted",...){
    if (!is.na(pmatch(method, "all"))) 
        method <- "unrooted"
    METHOD <- c("unrooted", "rooted")
    method <- pmatch(method, METHOD)
    if (is.na(method)) stop("invalid method")
    if (method == -1) stop("ambiguous method")
    if(!is.rooted(tree) & method==2) stop("tree has to be rooted")  
    if(method==1) X <- designUnrooted(tree,...)
    if(method==2) X <- designUltrametric(tree,...)
    X
}

designUnrooted = function(tree,order=NULL){
	tree = unroot(tree)
	p=bipartition(tree)
	if(!is.null(order)) p=p[,order]
    n = dim(p)[1]
    m = dim(p)[2]
    res = matrix(0,(m-1)*m/2, n)
	k = 1
    for(i in 1:(m-1)){
    	for(j in (i+1):m){
    		res[k,] = p[,i]!=p[,j]
    		k=k+1
    	}
    }
    colnames(res) = paste(tree$edge[,1],tree$edge[,2],sep="<->")
	res
    }
    

designUltrametric = function (tree, order = NULL) 
{
    edge = tree$edge
    child = edge[, 2]
    parent = edge[, 1]
    k = min(parent) - 1
    l = dim(edge)[1]
    res = matrix(0, l+1, l)

    for (i in 1:(l+1)) {
        ind = which(child == i)
        res[i, ind] = 1
        if(i <= k){
        p = parent[ind]
        while (p != (k + 1)) {
            ind = which(child == p)
            res[i, ind] = 1
            p = parent[ind]
        }
        } 
    }
    w = which(child > k)
    colnames(res) = child
    res = res[, w]
    p = dim(res)[2]
    contrast = cbind(I=1,-res[child,])
    contrast = matrix(0,l,p+1)
    contrast[,-1] =  -res[child,]
    contrast[,1] = 1
    ind = which(child>k)
    contrast[ind,1] = 0
    contrast[ind,] = contrast[ind,]* (-1)
    res = res[1:k,]
    
    result = matrix(0, k * (k - 1)/2, p)
    m = 1
    for (i in 1:(k - 1)) {
        for (j in (i + 1):k) {
            result[m, ] = res[i, ] * res[j, ]
            m = m + 1
        }
    }

    result = cbind(1, -result) * 2
    colnames(result) = c("I", paste("N", colnames(res), sep = ""))
    attr(result, "contrast") = contrast
    result
}


designSplits <- function (x, splits = "all", ...) 
{
    if (!is.na(pmatch(splits, "all"))) 
        splits <- "all"
    SPLITS <- c("all", "star") #,"caterpillar")
    splits <- pmatch(splits, SPLITS)
    if (is.na(splits)) stop("invalid splits method")
    if (splits == -1) stop("ambiguous splits method")  
    if(splits==1) X <-  designAll(x)
    if(splits==2) X <-  designStar(x)
    return(X)
}


designAll <- function(n){
    Y = matrix(0, n*(n-1)/2, n)
    k = 1
    for(i in 1:(n-1)){
    for(j in (i+1):n){
          Y[k,c(i,j)]=1
          k=k+1
        }
    }
    m <- n-1
    X <- matrix(0, m+1, 2^m)
    for(i in 1:m)
    X[i, ] <- rep(rep(c(0,1), each=2^(i-1)),2^(m-i))
    X <- X[,-1]
    list(X=(Y%*%X)%%2,Splits=t(X))
}



designStar = function(n){
	res=NULL
	for(i in 1:(n-1)) res = rbind(res,cbind(matrix(0,(n-i),i-1),1,diag(n-i)))
	res
}


PNJ <- function (data) 
{
    q <- l <- r <- length(data)
    weight <- attr(data,"weight")
        
    height = NULL    
    parentNodes <- NULL
    childNodes <- NULL    
    nam <- names(data)
    tip.label <- nam
    edge = 1:q
    
    z = 0
    D = matrix(0, q, q)
    
    for (i in 1:(l - 1)) {
        for (j in (i + 1):l) {
            w = (data[[i]] * data[[j]]) %*% c(1, 1, 1, 1)
            D[i, j] = sum(weight[w==0])
        }
    }

    while (l > 1) {
        l = l - 1
        z = z + 1
        d = D + t(D)
        if(l>1) r = rowSums(d)/(l-1)
        if(l==1) r = rowSums(d)
        M = d - outer(r,r,"+")
        diag(M) = Inf

        e=which.min(M)
        e0=e%%length(r)
        e1 = ifelse(e0==0, length(r), e0)
        e2= ifelse(e0==0, e%/%length(r), e%/%length(r) + 1)
        
        ind = c(e1,e2)       
        len = d[e]/2
        nam = c(nam[-ind], as.character(-l))
           
        parentNodes = c(parentNodes,-l,-l)            
        childNodes = c(childNodes,edge[e1],edge[e2])        
        
        height = c(height, len, len)
        edge = c(edge[-ind], -l)
        w = (data[[e1]] * data[[e2]]) %*% c(1, 1, 1, 1)
        w = which(w == 0)
        newDat = data[[e1]] * data[[e2]]
        newDat[w, ] = data[[e1]][w, ] + data[[e2]][w, ]   
        data = data[-c(e1,e2)]
        data[[l]] = newDat 
        if (l > 1) {
            D = as.matrix(D[, -ind])
            D = D[-ind, ]
            dv = numeric(l - 1)
            for (i in 1:(l - 1)) {
                w = (data[[i]] * data[[l]]) %*% c(1, 1, 1, 1)
                dv[i] = sum(weight[w==0])
            }
            D = cbind(D, dv)
            D = rbind(D, 0)
        }
    }
    tree <- list(edge = cbind(as.character(parentNodes),as.character(childNodes)),tip.label=tip.label) #,edge.length=height
    class(tree) <- "phylo"
    tree <- old2new.phylo(tree)
    #as.phylo.phyloNode(as.phyloNode.phylo(tree),"pruningwise")  
    read.tree(text=write.tree(tree))    
}


bipartition <- function (tree) 
{
    bp <- .Call("bipartition", as.integer(tree$edge), length(tree$tip), as.integer(tree$Nnode), PACKAGE = "ape")
    nTips = length(tree$tip)
    l = length(bp)
    m = length(bp[[1]])
    k = length(tree$edge[, 1])
    result = matrix(0, l, m)
    res = matrix(0, k, m)
    for (i in 1:l) result[i, bp[[i]]] = 1
    result = result[-1, ,drop=FALSE]
    for (i in 1:nTips) res[which(tree$edge[, 2] == i), i] = 1
    res[tree$edge[, 2] > nTips, ] = result[rank(tree$edge[ tree$edge[, 2] > nTips ,2]),]
    colnames(res) = tree$tip.label
    rownames(res) = tree$edge[,2]
    res[res[, 1] == 1, ] = 1 - res[res[, 1] == 1, ]
    res
}


ancestor2 <- function (phy, node) phy$pvector[node]

ancestors2 <- function (phy, node, which = c("all", "parent")) 
{
    which <- match.arg(which)
    if (which == "parent") 
        return(ancestor2(phy, node))
    res <- numeric(0)
    n <- sum(phy$tips)
    repeat {
        anc <- ancestor2(phy, node)
        res <- c(res, anc)
        node <- anc
        if (anc == n + 1) break
    }
    res
}



pmlCluster <- function (formula, fit, weight, p = 4, part = NULL, ...) 
{
	call <- match.call()
    form <- phangornParseFormula(formula)
    opt <- c("nni", "bf", "Q", "inv", "shape", "edge", "rate")
    optAll <- match(opt, form$left)
    optPart <- match(opt, form$right)
    AllBf <- !is.na(optAll[2])
    AllQ <- !is.na(optAll[3])
    AllInv <- !is.na(optAll[4])
    AllGamma <- !is.na(optAll[5])
    AllEdge <- !is.na(optAll[6])
    PartNni <- !is.na(optPart[1])
    PartBf <- !is.na(optPart[2])
    PartQ <- !is.na(optPart[3])
    PartInv <- !is.na(optPart[4])
    PartGamma <- !is.na(optPart[5])
    PartEdge <- !is.na(optPart[6])
    PartRate <- !is.na(optPart[7])
    nrw <- dim(weight)[1]
    ncw <- dim(weight)[2]
    if (is.null(part)) 
        part = sample(rep(1:p, length=ncw))
    Part = part
    Gtrees = list()
    dat <- fit$data
    attr(fit$orig.data, "index") <- attr(dat, "index") <- NULL
    for (i in 1:p) Gtrees[[i]] = fit$tree
    fits = list()
    for (i in 1:p) fits[[i]] = fit
    eps = 0
    m = 1
    logLik = fit$log
    trees = list()
    oldpart <- rep(0, ncw)

#  erste optimierung    
    
        weights = list()
        for (i in 1:p) {
            weights[[i]] = rowSums(matrix(weight[, which(part == 
            i)], nrow = nrw))
        }
        lls = list()
        result = list()
        loli = 0
        for (i in 1:p) {
            if (!identical(part == i, oldpart == i)) {
                ind <- which(weights[[i]] > 0)
                dat2 <- getRows(dat, ind)
                attr(dat2, "weight") <- weights[[i]][ind]
                fits[[i]] <- update(fits[[i]], data = dat2)
                fits[[i]] = optim.pml(fits[[i]], PartNni, PartBf, 
                  PartQ, PartInv, PartGamma, PartEdge, PartRate, 
                  control = list(maxit = 3, eps = 0.001))
            }
            lls[[i]] = update(fits[[i]], data = dat)$site
            loli = loli + fits[[i]]$log
            cat(i, ":", loli, "\n")
            Gtrees[[i]] = fits[[i]]$tree
         }
    
    logLik = c(logLik, loli)    
    eps2 =100
    while (eps < ncw && abs(eps2)>0.01) {

        df2 = 0
        if (AllQ) {
            newQ <- optimPartQ(fits)[[1]]
            for (i in 1:p) fits[[i]] <- update(fits[[i]], Q = newQ)
            df2 = df2 + length(unique(newQ)) - 1
        }
        if (AllBf) {
            newBf <- optimPartBf(fits)
            for (i in 1:p) fits[[i]] <- update(fits[[i]], bf = newBf)
            df2 = df2 + length(unique(newBf)) - 1
        }
        if (AllInv) {
            newInv <- optimPartInv(fits)
            for (i in 1:p) fits[[i]] <- update(fits[[i]], Inv = newInv)
            df2 = df2 + 1
        }
        if (AllGamma) {
            newGamma <- optimPartGamma(fits)[[1]]
            for (i in 1:p) fits[[i]] <- update(fits[[i]], shape = newGamma)
            df2 = df2 + 1
        }
        if (AllEdge) {
            fits <- optimPartEdge(fits)
            df2 = df2 + length(fits[[1]]$tree$edge.length)
        }
        for (i in 1:p) lls[[i]] = update(fits[[i]], data = dat)$site
        trees[[m]] = Gtrees
        LL = matrix(0, ncw, p)
        for (j in 1:p) {
            LL[, j] = t(weight) %*% lls[[j]]
        }

        oldpart = part
        part = apply(LL, 1, which.max)

        eps = sum(diag(table(part, oldpart)))
         for (i in 1:ncw) {
            print(i)  
            part = apply(LL, 1, which.max)
                
            a = part[i]
            b = oldpart[i]
            part = oldpart
            part[i] = a
            if(a != b){                      
                for (j in c(a, b)) {
                    weights[[j]] = rowSums(matrix(weight[, which(part == j)], nrow = nrw))
                    ind <- which(weights[[j]] > 0)
                    dat2 <- getRows(dat, ind)
                    attr(dat2, "weight") <- weights[[j]][ind]
                    fits[[j]] <- update(fits[[j]], data = dat2)
                    fits[[j]] = optim.pml(fits[[j]], PartNni, PartBf, 
                      PartQ, PartInv, PartGamma, PartEdge, PartRate, 
                      control = list(maxit = 3, eps = 0.001))
                    lls[[j]] = update(fits[[j]], data = dat)$site
                }
                LL = matrix(0, ncw, p)
                for (v in 1:p) {
                    LL[, v] = t(weight) %*% lls[[v]]
                }
                
                oldpart = part
            }  # end if
        }  # end for   
        eps = sum(diag(table(apply(LL, 1, which.max), oldpart)))
          
        eps2 = loli
        loli=sum(apply(LL,1,max))
        eps2 = eps2-loli
#        print(eps2)
        logLik = c(logLik, loli) 
        print(logLik)
        Part = cbind(Part, part)
        df2 = df2 + df2
        m = m + 1
    }
#    df = df2
#    for (i in 1:p) df = df + fits[[i]]$df
    
    df <- matrix(1, 6 ,2)
    colnames(df) <- c("#df", "group")
    rownames(df) <- c("Edge", "Shape", "Inv", "Bf", "Q", "Rate")
    df[1,1] <- length(fits[[1]]$tree$edge.length)
    df[2,1] <- fits[[1]]$k - 1
    df[3,1] <- fits[[1]]$inv > 0
    df[4,1] <- length(unique(fits[[1]]$bf)) - 1
    df[5,1] <- length(unique(fits[[1]]$Q)) - 1
    df[6,1] <- 0 # rates 
    if(PartEdge) df[1,2] = p
    if(PartGamma) df[2,2] = p
    if(PartInv) df[3,2] = p
    if(PartBf) df[4,2] = p
    if(PartQ) df[5,2] = p
    if(PartRate) df[6,1] = p-1     
    attr(logLik, "df") = sum(df[,1]*df[,2])
#    object <- list(logLik = logLik, fits = fits, call = call, df=df) 
   
    res = list(logLik = logLik, Partition = Part, trees = trees)
    result <- list(logLik = loli, fits = fits, Partition = part, 
        df = df, res = res, call=call)    
    class(result) <- "pmlPart"
    result
}


readAArate <- function(file){
    tmp <- read.table(system.file(file.path("data", file), package = "phangorn"), col.names = 1:20, fill=TRUE)
    Q <- tmp[1:19,1:19]
    names <- c("a", "r", "n", "d", "c", "q", "e", "g", "h", "i", "l", "k", "m", "f", "p", "s", "t", "w",  "y", "v")
    Q <- as.numeric(Q[lower.tri(Q,TRUE)])
    bf <- as.numeric(as.character(unlist(tmp[20,])))
    names(bf) <- names
    list(Q=Q, bf=bf)
}


.LG <- readAArate("lg.dat")
.WAG <- readAArate("wag.dat")
.Dayhoff <- readAArate("dayhoff-dcmut.dat")
.JTT <- readAArate("jtt-dcmut.dat")



pml <- function (tree, data, bf = NULL, Q = NULL, inv = 0, k = 1, shape = 1, 
    rate = 1, model="", ...) 
{
    call <- match.call()
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "pruningwise")
    if (class(data)[1] != "phyDat") 
        stop("data must be of class phyDat")
    levels <- attr(data, "levels")
    weight <- attr(data, "weight")
    nr <- attr(data, "nr")
    type <- attr(data,"type")
    if(type=="AA" & !is.null(model)){
        model <- match.arg(model, c("", "WAG", "JTT", "LG", "Dayhoff"))
        if (model == "WAG") {
            Q <- .WAG$Q
            if(is.null(bf))bf <- .WAG$bf
        }
        if (model == "JTT") {
            Q <- .JTT$Q
            if(is.null(bf))bf <- .JTT$bf
        }
        if (model == "LG") {
            Q <- .LG$Q
            if(is.null(bf))bf <- .LG$bf
        }
        if (model == "Dayhoff") {
            Q <- .Dayhoff$Q
            if(is.null(bf))bf <- .Dayhoff$bf
        }
    }

    if (is.null(bf)) 
        bf <- rep(1/length(levels), length(levels))
    if (is.null(Q)) 
        Q <- rep(1, length(levels) * (length(levels) - 1)/2)
    m <- 1
    eig <- edQt(bf = bf, Q = Q)
    w <- rep(1/k, k)
    if (inv > 0) 
        w <- (1 - inv) * w
    g <- discrete.gamma(shape, k)
    if (inv > 0) 
        g <- g/(1 - inv)
    g <- rate * g
    INV <- lli(data, tree)#, bf)
    ll.0 <- INV %*% (bf * inv)
    resll <- matrix(0, nr, k)
    while (m <= k) {
        resll[,m] = ll(data, tree, bf = bf, g = g[m], Q = Q, 
            eig = eig, assign.dat = FALSE, ...)
        m = m + 1
    }
    lll <- resll %*% w
    siteLik <- lll + ll.0
    siteLik <- log(siteLik)
    loglik = sum(weight * siteLik)
    df = length(tree$edge.length) + k - 1 + (inv > 0) + length(unique(bf)) - 
        1 + length(unique(Q)) - 1
    result = list(logLik = loglik, inv = inv, k = k, shape = shape,
        Q = Q, bf = bf, rate = rate, siteLik = siteLik, weight = weight, 
        g = g, w = w, eig = eig, data = data, model=model, INV = INV, 
        ll.0 = ll.0, tree = tree, lv = resll, call = call, df=df, wMix=0, llMix=NULL)
    class(result) = "pml"
    result
}



print.pml = function(x,...){
	cat("\nloglikelihood:", x$logLik, "\n")
    w <- x$weight
    w <- w[w>0]	
    type <- attr(x$data, "type")
    levels <- attr(x$data, "levels")
    nc <- attr(x$data, "nc")
    ll0 = sum(w*log(w/sum(w)))
    cat("\nunconstrained loglikelihood:", ll0, "\n\n")
	if(x$inv > 0)cat("Proportion of invariant sites:",x$inv,"\n")
	if(x$k >1){
		cat("Discrete gamma model\n")
		cat("Number of rate categories:",x$k,"\n")		
		cat("Shape parameter:",x$shape,"\n")
		}
	if(type=="AA") cat("Rate matrix:",x$model, "\n")	
    if(type=="DNA"){
        cat("\nRate matrix:\n")	
        QM = matrix(0, nc, nc, dimnames = list(levels,levels))	
        QM[lower.tri(QM)] = x$Q	
        QM = QM+t(QM)
        print(QM)
        cat("\nBase frequencies:  \n")
        bf = x$bf
        names(bf) = levels 
        cat(bf, "\n")
    }
    
    if(type=="USER" & length(x$bf)<11){ 	    
        cat("\nRate matrix:\n")	
        QM = matrix(0, nc, nc, dimnames = list(levels,levels))	
        QM[lower.tri(QM)] = x$Q	
        QM = QM+t(QM)
        print(QM)
        cat("\nBase frequencies:  \n")
        bf = x$bf
        names(bf) = levels 
        cat(bf, "\n")
    }        
}	



optEdgeMulti <- function (object, ...) 
{
    tree <- object$tree
    theta <- object$tree$edge.length
    weight <- attr(object$data, "weight")
    ll0 = object$logLik
    eps = 1
    iter = 0
    while (abs(eps) > 1e-5 && iter < 25) {
        dl = score(object)
        thetaNew = log(theta) + solve(dl[[2]], dl[[1]])
        theta = exp(thetaNew)
        tree$edge.length = as.numeric(theta)
        object <- update(object, tree = tree)
        ll1 = object$logLik
        eps <- ll1 - ll0
        cat("loglik: ",ll0,"\n")
        cat("eps: ",eps,"\n") 
        ll0 <- ll1
        print(ll1)
        iter <- iter+1
    }
    object
}


update.pml <- function (object, ...) 
{
    extras <- match.call(expand.dots = FALSE)$...
    pmla <- c("tree", "data", "bf", "Q", "inv", "k", "shape", 
        "rate", "model", "wMix", "llMix", "...") ## "ll.0", "w", 
    names(extras) <- pmla[pmatch(names(extras), pmla[-length(pmla)])]
    existing <- match(pmla, names(extras))

    updateRates <- FALSE

    if (is.na(existing[1])) tree <- object$tree
    else tree <- eval(extras[[existing[1]]], parent.frame())

    if (is.na(existing[2])){
        data <- object$data
        INV <- object$INV
        }
    else{ 
        data <- eval(extras[[existing[2]]], parent.frame())
        ll.0 <- numeric(attr(data,"nr"))
        INV <- lli(data, tree)
    }
    nr <- attr(data, "nr")
    
    if (is.na(existing[3])) bf <- object$bf
    else bf <- eval(extras[[existing[3]]], parent.frame())

    if (is.na(existing[4])) Q <- object$Q
    else Q <- eval(extras[[existing[4]]], parent.frame())

    model <- object$model
    type <- attr(object$data, "type")
    if (!is.na(existing[9]) & type == "AA") {
        model <- match.arg(extras[[existing[9]]], c("WAG", "JTT", "LG", "Dayhoff"))
        if (model == "WAG") {
            Q <- .WAG$Q
            if (is.na(existing[3])) bf <- .WAG$bf
        }
        if (model == "JTT") {
            Q <- .JTT$Q
            if (is.na(existing[3])) bf <- .JTT$bf
        }
        if (model == "LG") {
            Q <- .LG$Q
            if (is.na(existing[3])) bf <- .LG$bf
        }
        if (model == "Dayhoff") {
            Q <- .Dayhoff$Q
            if (is.na(existing[3])) bf <- .Dayhoff$bf
        }
    }
    
    if(is.na(existing[5])) inv <- object$inv
    else{
        inv <- eval(extras[[existing[5]]], parent.frame())
        updateRates <- TRUE
    }

    if(is.na(existing[6])) k <- object$k
    else{
        k <- eval(extras[[existing[6]]], parent.frame())
        updateRates <- TRUE
    }
    
    if(is.na(existing[7])) shape <- object$shape
    else{
        shape <- eval(extras[[existing[7]]], parent.frame())
        updateRates <- TRUE
    }

    rate <- ifelse(is.na(existing[8]), object$rate, eval(extras[[existing[8]]], parent.frame()))
    
    wMix <- ifelse(is.na(existing[10]), object$wMix, eval(extras[[existing[10]]], parent.frame()))
    
    if(is.na(existing[11])) llMix <- object$llMix
    else llMix <- eval(extras[[existing[11]]], parent.frame())
                
    levels <- attr(data, "levels")
    weight <- attr(data, "weight")
    
    eig <- edQt(bf = bf, Q = Q)
    g <- discrete.gamma(shape, k)
    g <- rate * g 
    
    if (inv > 0) g <- g/(1 - inv)
    
    ll.0 <- INV %*% (bf * inv)
    if(wMix>0) ll.0 <- ll.0 + llMix

    w = rep(1/k, k)
    if (inv > 0) 
        w <- (1 - inv) * w
    if (wMix > 0) 
        w <- wMix * w     # (1 - wMix) 
              
    m <- 1
    resll <- matrix(0, nr, k)
    while (m <= k) {
        resll[,m] = ll(data, tree, bf, g[m], Q, eig, assign.dat = FALSE)
        m = m + 1
    }

    lll = resll %*% w
    siteLik = log(lll + ll.0)
    loglik = sum(weight * siteLik)
    df = length(tree$edge.length) + k - 1 + (inv > 0) + length(unique(bf)) - 
        1 + length(unique(Q)) - 1
     result = list(logLik = loglik, inv = inv, k = k, shape = shape,
        Q = Q, bf = bf, rate = rate, siteLik = siteLik, weight = weight, 
        g = g, w = w, eig = eig, data = data, model=model, INV = INV, 
        ll.0 = ll.0, tree = tree, lv = resll, call = call, df=df, wMix=0, llMix=NULL)
    class(result) = "pml"
    result
}


optimMixQ <- function(object, Q=c(1, 1, 1, 1, 1, 1), omega,...){
    l = length(Q)
    Q = Q[-l]
    Q = sqrt(Q)
    fn = function(Q, object, omega,...) {
        Q = c(Q^2, 1)
        weight <- object[[1]]$weight
        n <- length(omega)
        p <- length(weight)
        result <- numeric(p)
        for(i in 1:n)result <- result + as.numeric(update(object[[i]], Q=Q, ...)$lv) * omega[i]
        result <- sum(weight %*% log(result))
        result 
    }
    res = optim(par=Q, fn=fn, gr=NULL, method="L-BFGS-B", lower=0, 
            upper=Inf, control=list(fnscale = -1, maxit=25), 
            object=object, omega=omega,...)
    res[[1]] = c(res[[1]]^2, 1)
    res
}


optimMixBf <- function(object, bf=c(.25,.25,.25,.25), omega,...){
    l = length(bf)
    nenner = 1/bf[l]
    lbf = log(bf * nenner)
    lbf = lbf[-l]
    fn = function(lbf, object, omega,...) {
    bf = exp(c(lbf,0))
    bf = bf/sum(bf)
    weight <- object[[1]]$weight
        n <- length(omega)
        p <- length(weight)
        result <- numeric(p)
        for(i in 1:n)result <- result + as.numeric(update(object[[i]], bf=bf, ...)$lv) * omega[i]
        result <- sum(weight %*% log(result))
        result 
    }
    res = optim(par=lbf, fn=fn, gr=NULL, method="Nelder-Mead", 
        control=list(fnscale=-1, maxit=500), object, omega=omega,...)
    print(res[[2]])
    bf = exp(c(res[[1]],0))
    bf = bf/sum(bf)
}


optimMixInv <- function(object, inv=0.01, omega,...){
    fn = function(inv, object, omega,...) {
        n <- length(omega)
        weight <- object[[1]]$weight
        p <- length(weight)
        result <- numeric(p)
         for(i in 1:n)result <- result + as.numeric(update(object, inv=inv, ...)$lv) * omega[i]
        result <- sum(weight %*% log(result))
        result 
    }
    res = optimize(f=fn, interval = c(0,1), lower = 0, upper = 1, maximum = TRUE,
        tol = .0001, object, omega=omega,...)
    print(res[[2]]) 
    res[[1]]
}




pml2 <- function (tree, data, bf = rep(1/length(levels), length(levels)), 
    shape = 1, k = 1, Q = rep(1, length(levels) * (length(levels) - 1)/2), 
    levels = attr(data, "levels"), inv = 0, rate = 1, g = NULL, w = NULL, 
    eig = NULL, INV = NULL, ll.0 = NULL, llMix = NULL, wMix = 0, ...) 
{
    if (is.null(attr(tree, "order")) || attr(tree, "order") == 
        "cladewise") 
        tree <- reorder(tree, "pruningwise")
    if (class(data)[1] != "phyDat") 
        stop("data must be of class phyDat")
    weight = attr(data, "weight")
    l = length(bf)
    lll = matrix(0, length(weight), l)
    m = 1
    if (is.null(eig)) 
        eig = edQt(bf = bf, Q = Q)
    if (is.null(w)) {
        w = rep(1/k, k)
        if (inv > 0) 
            w <- (1 - inv) * w
        if (wMix > 0) 
            w <- (1 - wMix) * w           
    }
    if (is.null(g)) {
        g = discrete.gamma(shape, k)
        if (inv > 0) 
            g <- g/(1 - inv)
        g <- g * rate     
    } 
    if (is.null(INV)) 
        INV = lli(data, tree)#, bf)
    if (is.null(ll.0)) 
        ll.0 <- numeric(attr(data,"nr"))
    if(inv>0) 
        ll.0 = INV %*% (inv * bf)               
    if (wMix > 0)
         ll.0 <- ll.0 + llMix           
    p = length(g)
    nr <- attr(data, "nr")    
    resll <- matrix(0, nr, k)
    while (m <= k) {
        resll[,m] = ll(data, tree, bf = bf, g = g[m], Q = Q, 
            eig = eig, assign.dat = FALSE, ...)
        m = m + 1
    }
    lll <- resll %*% w         
    siteLik <- lll + ll.0
    if(wMix >0) siteLik <- siteLik * (1-wMix) + llMix
    siteLik = log(siteLik)
    sum(weight * siteLik)
}

	



optimMixRate <- function (fits, ll, weight, omega, rate=rep(1,length(fits))) 
{
    r <- length(fits)
    rate0 <- rate[-r]   

    fn<-function(rate, fits, ll, weight, omega){
        r <-  length(fits)
        rate <- c(rate, (1- sum(rate *omega[-r]))/omega[r])
        for (i in 1:r) fits[[i]]<-update(fits[[i]], rate = rate[i])
        for (i in 1:r) ll[, i] <- fits[[i]]$lv
        sum(weight*log(ll%*%omega)) 
    }
    ui=diag(r-1)
    ui <- rbind(-omega[-r], ui)
    ci <- c(-1, rep(0, r-1))
    res <- constrOptim(rate0, fn, grad=NULL, ui=ui, ci=ci, mu = 1e-04, control = list(fnscale=-1),
        method = "Nelder-Mead", outer.iterations = 50, outer.eps = 1e-05, fits, ll, weight, omega)
    rate <- res[[1]]
    res[[1]] <- c(rate, (1- sum(rate *omega[-r]))/omega[r])
    res
}



optW <- function (ll, weight, omega,...) 
{
    k = length(omega)
    nenner = 1/omega[1]
    eta = log(omega * nenner)
    eta = eta[-1]
    fn = function(eta, ll, weight) {
        eta = c(0,eta)
        p = exp(eta)/sum(exp(eta))
        res = sum(weight * log(ll %*% p)) 
        res
    }
    if(k==2)res = optimize(f =fn , interval =c(-3,3) , lower = -3, upper = 3, maximum = TRUE, tol = .Machine$double.eps^0.25, ll = ll, weight = weight) 
    else res = optim(eta, fn = fn, method = "L-BFGS-B", lower=-5, upper=5,control = list(fnscale = -1, 
        maxit=25), gr = NULL, ll = ll, weight = weight)

    p = exp(c(0,res[[1]]))
    p = p/sum(p)
    result = list(par = p, value = res[[2]])
    result
}


optimMixEdge <- function(object, omega,...){
    tree <- object[[1]]$tree
    theta <- object[[1]]$tree$edge.length
    weight = as.numeric(attr(object[[1]]$data,"weight"))
    n <- length(omega)
    p <- length(weight)
    q <- length(theta)
    lv1 = numeric(p)
    for(i in 1:n) lv1 = lv1 + as.numeric(object[[i]]$lv) * omega[i]
    ll0 <- sum(weight * log(lv1))
    eps=1
    iter <- 0
    scalep <- 1
    cat(ll0)
    while(abs(eps)>.001 & iter<10){
        dl <- matrix(0,p,q)
        for(i in 1:n)dl <- dl + dl(object[[i]],TRUE) * omega[i]
        dl <- dl/lv1
        sc = colSums(weight * dl)
        F = crossprod(dl * weight, dl)+diag(q)*1e-6
        blub <- TRUE
        iter2 <- 0
        while(blub & iter2<10){
        thetaNew = log(theta) + scalep * solve(F, sc)
        tree$edge.length = as.numeric(exp(thetaNew))
        for(i in 1:n)object[[i]] <- update(object[[i]],tree=tree)
        lv1 = numeric(p)
        for(i in 1:n) lv1 = lv1 + as.numeric(object[[i]]$lv)  * omega[i]
        ll1 <- sum(weight * log(lv1))
        eps <- ll1 - ll0     
        if (eps < 0) {
            scalep = scalep/2
            eps = 1
            thetaNew = log(theta)
            ll1 = ll0
            iter2 <- iter2+1
        }
        else{
             scalep = 1;
             theta = exp(thetaNew)  
             blub=FALSE  
            }     
        }             
        iter <- iter+1
#        cat("eps: ", eps, "ll: ", ll1, "\n")
        ll0 <- ll1
    }       
    tree$edge.length <- theta
    for(i in 1:n)object[[i]] <- update(object[[i]],tree=tree)
    cat("->", ll1, "\n")
    object
}



pmlMix <- function (formula, fit, m = 2, omega = rep(1/m, m), ...) 
{
    call <- match.call()
    form <- phangornParseFormula(formula)
    opt <- c("nni", "bf", "Q", "inv", "shape", "edge", "rate")
    optAll <- match(opt, form$left)
    optPart <- match(opt, form$right)
    AllBf <- !is.na(optAll[2])
    AllQ <- !is.na(optAll[3])
    AllInv <- !is.na(optAll[4])
    AllGamma <- !is.na(optAll[5])
    AllEdge <- !is.na(optAll[6])
    MixNni <- !is.na(optPart[1])
    MixBf <- !is.na(optPart[2])
    MixQ <- !is.na(optPart[3])
    MixInv <- !is.na(optPart[4])
    MixGamma <- !is.na(optPart[5])
    MixEdge <- !is.na(optPart[6])
    MixRate <- !is.na(optPart[7])
    if (class(fit) == "list") 
        fits <- fit
    else {
        fits <- list()
        for (i in 1:m) fits[[i]] <- fit
    }
#    for(i in 1:r)fits[[i]]<-update(fits[[i]], k=1)  
    dat <- fits[[1]]$data
    p = attr(dat, "nr")
    weight = attr(dat, "weight")
    r = m
    ll = matrix(0, p, r)
    for (i in 1:r) ll[, i] = fits[[i]]$lv

    for (i in 1:r){
         pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
         fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
    }

    if(MixRate) rate <- rep(1,r)

    llstart = sum(weight * log(ll %*% omega))
    llold <- llstart
    ll0 <- llstart
    ll3 <- llstart
    eps0 <- 100
    iter0 <- 0
    while (eps0 > 1e-6 & iter0 < 20) {
        eps1 <- 100
        iter1 <- 0
        
        if (AllQ) {
            newQ <- optimMixQ(fits, Q = fits[[1]]$parameter$Q, 
                omega = omega)[[1]]
            for (i in 1:m) fits[[i]] <- update(fits[[i]], Q = newQ)
        }
        if (AllBf) {
            newBf <- optimMixBf(fits, bf = fits[[1]]$parameter$bf, 
                omega = omega)
            for (i in 1:m) fits[[i]] <- update(fits[[i]], bf = newBf)
        }
        if (AllInv) {
            newInv <- optimMixInv(fits, inv = fits[[1]]$parameter$inv, 
                omega = omega)
            for (i in 1:m) fits[[i]] <- update(fits[[i]], Inv = newInv)
        }
        if (AllEdge) 
            fits <- optimMixEdge(fits, omega)
        for (i in 1:r) ll[, i] <- fits[[i]]$lv

        while ( abs(eps1) > 0.001 & iter1 < 3) {
             if(MixRate){
                 rate <- optimMixRate(fits, ll, weight, omega, rate)[[1]]
                 for (i in 1:r) fits[[i]] <- update(fits[[i]], rate=rate[i]) 
                 for (i in 1:r) ll[, i] <- fits[[i]]$lv
            }
    for (i in 1:r){
         pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
         fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
    }

            for (i in 1:r) {
                pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
                fits[[i]] <- optim.pml(fits[[i]], MixNni, MixBf, MixQ, MixInv, MixGamma, 
                    MixEdge, optRate=FALSE, control = list(maxit = 3, 
                    eps = 0.001), llMix = pl0, wMix = omega[i])
                 ll[, i] <- fits[[i]]$lv 

            
 
             res = optW(ll, weight, omega)
               omega = res$p
            
             if(MixRate){
                     blub <- sum(rate*omega)
                     rate <- rate / blub 
                     tree <- fits[[1]]$tree
                     tree$edge.length <-   tree$edge.length*blub
                     for (i in 1:r) fits[[i]]<-update(fits[[i]], tree=tree, rate = rate[i])
                     for (i in 1:r) ll[, i] <- fits[[i]]$lv
             }
             for (i in 1:r){
                 pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
                 fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
             }
             
            }
            ll1 = sum(weight * log(ll %*% omega))

            res = optW(ll, weight, omega)
            omega = res$p
             if(MixRate){
                     blub <- sum(rate*omega)
                     rate <- rate / blub 
                     tree <- fits[[1]]$tree
                     tree$edge.length <-   tree$edge.length*blub
                     for (i in 1:r) fits[[i]]<-update(fits[[i]], tree=tree, rate = rate[i])
                     print(rate)
                     for (i in 1:r) ll[, i] <- fits[[i]]$lv
             }
    for (i in 1:r){
         pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
         fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
    }

            ll2 = sum(weight * log(ll %*% omega)) # res$value
            eps1 = llold - ll2
            iter1 <- iter1 + 1
            llold = ll2
        }   

        ll1 <- sum(weight * log(ll %*% omega))
        eps0 <- ll1 - ll3
        ll3 <- ll1
        iter0 <- iter0 + 1
        print(iter0)
    }
    parameter <- c(AllBf=AllBf, AllQ=AllQ, AllInv=AllInv, AllGamma=AllGamma, AllEdge=AllEdge, MixNni=MixNni, 
       MixBf=MixBf, MixQ=MixQ, MixInv=MixInv, MixGamma=MixGamma, MixEdge=MixEdge, MixRate=MixRate)
    
    df <- matrix(1, 6 ,2)
    colnames(df) <- c("#df", "group")
    rownames(df) <- c("Edge", "Shape", "Inv", "Bf", "Q", "Rate")
    df[1,1] <- length(fits[[1]]$tree$edge.length)
    df[2,1] <- fits[[1]]$k - 1
    df[3,1] <- fits[[1]]$inv > 0
    df[4,1] <- length(unique(fits[[1]]$bf)) - 1
    df[5,1] <- length(unique(fits[[1]]$Q)) - 1
    df[6,1] <- 0 # rates 
    if(MixEdge) df[1,2] = r
    if(MixGamma) df[2,2] = r
    if(MixInv) df[3,2] = r
    if(MixBf) df[4,2] = r
    if(MixQ) df[5,2] = r
    if(MixRate) df[6,1] = r-1     
    attr(logLik, "df") = sum(df[,1]*df[,2])
    converge <- c(iter=iter0, eps=eps0)
    result <- list(logLik = ll1, omega = omega, fits = fits, call = call, converge=converge, parameter=parameter, df=df)
    class(result) <- "pmlMix"
    result
}



print.pmlMix <- function(x,...){
    nc <- attr(x$fits[[1]]$data, "nc")
    nr <- attr(x$fits[[1]]$data, "nr")
    levels <- attr(x$fits[[1]]$data, "levels")
    r <- length(x$fits)   
    w <- x$fits[[1]]$weight
    w <- w[w>0] 
    type <- attr(x$fits[[1]]$data, "type")
    nc <- attr(x$fits[[1]]$data, "nc")
    ll0 = sum(w*log(w/sum(w)))

    
    bf <- matrix(0,r,nc)
    dimnames(bf) <- list(1:r, levels)
    Q <- matrix(0, r, nc*(nc-1)/2)
    dimnames(Q) <- list(1:r, NULL)

    rate <- numeric(r)
    inv <- x$fits[[1]]$inv
    shape <- numeric(r)

    for(i in 1:r){
        bf[i, ] <- x$fits[[i]]$bf
        Q[i, ] <- x$fits[[i]]$Q
        rate[i] <- x$fits[[i]]$rate
        shape[i] <- x$fits[[i]]$shape
    }
    cat("\nloglikelihood:", x$logLik, "\n")
    cat("\nunconstrained loglikelihood:", ll0, "\n") 
    cat("AIC: ", AIC(x), " BIC: ", AIC(x, k=log(nr)), "\n\n")
    cat("\nposterior:", x$omega ,"\n")   
    if(inv > 0)cat("Proportion of invariant sites:",inv,"\n")
    cat("\nBase frequencies:  \n")
    print(bf)
    cat("\nRates:\n")
    cat(rate,"\n")
    cat("\nRate matrix:\n")
    print(Q)
}


logLik.pmlMix <- function (object, ...) 
{
    res <- object$logLik
    attr(res, "df") <- sum(object$df[,1] * object$df[,2])
    class(res) <- "logLik"
    res
}
 

print.pmlPart <- function(x,...){
    nc <- attr(x$fits[[1]]$data, "nc")
    levels <- attr(x$fits[[1]]$data, "levels")
    r <- length(x$fits)   
    nc <- attr(x$fits[[1]]$data, "nc")
    nr <- attr(x$fits[[1]]$data, "nr")
    bf <- matrix(0,r,nc)
    dimnames(bf) <- list(1:r, levels)
    Q <- matrix(0, r, nc*(nc-1)/2)
    dimnames(Q) <- list(1:r, NULL)

    loli <- numeric(r)
    rate <- numeric(r)
    inv <- x$fits[[1]]$inv
    shape <- numeric(r)
    sizes <- numeric(r)
      
    for(i in 1:r){
	    loli[i] <- x$fits[[i]]$logLik
        bf[i, ] <- x$fits[[i]]$bf
        Q[i, ] <- x$fits[[i]]$Q
        rate[i] <- x$fits[[i]]$rate
        shape[i] <- x$fits[[i]]$shape
        sizes[i] <- sum(attr(x$fits[[i]]$data,"weight"))
    }
    cat("\nloglikelihood:", x$logLik, "\n")
    cat("\nloglikelihood of partitions:\n ", loli, "\n")
    cat("AIC: ", AIC(x), " BIC: ", AIC(x, k=log(nr)), "\n\n")    
    if(inv > 0)cat("Proportion of invariant sites:",inv,"\n")
    cat("\nBase frequencies:  \n")
    print(bf)
    cat("\nRates:\n")
    cat(rate,"\n")
    
    cat("\nRate matrix:\n")
    print(Q)
}


logLik.pmlPart <- function (object, ...) 
{
    res <- object$logLik
    attr(res, "df") <- sum(object$df[,1] * object$df[,2])
    class(res) <- "logLik"
    res
}



pmlPen <- function(object, lambda, ...){
	if(class(object)=="pmlPart") return(pmlPartPen(object, lambda,...))
	if(class(object)=="pmlMix") return(pmlMixPen(object, lambda,...))
	else stop("object has to be of class pmlPart or pmlMix")
	}
   
	
	
pmlPartPen <- function(object, lambda,...){
	fits <- object$fits
	
    m <- length(fits)
    K = -diag(length(fits[[1]]$tree$edge.length))
    Ktmp=K
    for(i in 1:(m-1))Ktmp = cbind(Ktmp,K)
    KM = Ktmp
    for(i in 1:(m-1))KM = rbind(KM,Ktmp)
    diag(KM) = m-1
    theta=NULL
    l = length(fits[[1]]$tree$edge.length)
    loglik = 0
    for(i in 1:m){
        theta = c(theta,fits[[i]]$tree$edge.length)
        loglik = loglik + fits[[i]]$logLik
    }
    print(loglik)
    pen = - 0.5 * lambda * t(theta)%*%KM%*%theta
    loglik = loglik - 0.5 * lambda * t(theta)%*%KM%*%theta 
    eps=1
    H  = matrix(0, m * l, m * l)
    iter=0
    while( abs(eps)>.01 & iter<20){
        theta=NULL
        sc = NULL
        for(i in 1:m){
            theta = c(theta,fits[[i]]$tree$edge.length)
            scoretmp = score(fits[[i]], TRUE)
            sc = c(sc,scoretmp$sc)
            H[(1:l)+l*(i-1), (1:l)+l*(i-1)] = scoretmp$F
        }
        sc = sc - lambda * KM%*% log(theta)
        thetanew = log(theta) +  solve(H + lambda*KM, sc)
        for(i in 1:m) fits[[i]]$tree$edge.length = exp(thetanew[(1:l)+(i-1)*l])
        for(i in 1:m) fits[[i]] = update.pml(fits[[i]], tree=fits[[i]]$tree)
        loglik1 = 0
        for(i in 1:m) loglik1 = loglik1 + fits[[i]]$logLik
        logLik <- loglik1
        print(loglik1)
        loglik0 = loglik1
        pen = - 0.5 * lambda * t(theta)%*%KM%*%theta
        loglik1 = loglik1 - 0.5 * lambda * t(thetanew)%*%KM%*%thetanew
        eps =  abs(loglik1 - loglik)
        loglik = loglik1
        theta = exp(thetanew)
        iter = iter+1
        print(iter)
    }
    df = sum( diag(solve(H + lambda* KM, H)))
    
    object$df[1,1] = df
    object$df[1,2] = 1
    object$fits = fits
    object$logLik = loglik0
    object$logLik.pen = loglik      
    object
}



pmlMixPen = function (object, lambda, optOmega=TRUE, ...) 
{
    fits <- object$fits
    m <- length(fits)
    K = -diag(length(fits[[1]]$tree$edge.length))
    tree <- fits[[1]]$tree
    Ktmp = K
    for (i in 1:(m - 1)) Ktmp = cbind(Ktmp, K)
    KM = Ktmp
    for (i in 1:(m - 1)) KM = rbind(KM, Ktmp)
    diag(KM) = m - 1
    theta = NULL
    l = length(fits[[1]]$tree$edge.length)
    omega <- object$omega
    dat <- fits[[1]]$data
    nr = attr(dat, "nr")
    weight = drop(attr(dat, "weight"))
    ll = matrix(0, nr, m)
    for (i in 1:m) ll[, i] = fits[[i]]$lv
    lv = drop(ll %*% omega)
    loglik = sum(weight * log(lv))
    for (i in 1:m) theta = c(theta, fits[[i]]$tree$edge.length)
    pen = - 0.5 * lambda * t(theta) %*% KM %*% theta
    loglik = loglik + pen
    print(loglik)    
    eps0 = 1 
    dl <- matrix(0, nr, m * l)
    iter0 = 0
    while (abs(eps0) > 1e-6 & iter0 < 20) {
      eps = 1
      iter = 0      
      while (abs(eps) > 0.01 & iter < 5) {
        for (i in 1:m) {
            dl[, (1:l) + l * (i - 1)] <- dl(fits[[i]], TRUE) * 
                omega[i]
        }
        dl <- dl/lv
        sc = colSums(weight * dl) - lambda * KM %*% log(theta)
        H = crossprod(dl * weight, dl)
        thetanew = log(theta) + solve(H + lambda * KM, sc)
        for (i in 1:m) fits[[i]]$tree$edge.length = exp(thetanew[(1:l) + 
            (i - 1) * l])
        for (i in 1:m) {
            tree$edge.length = exp(thetanew[(1:l) + (i - 1) * 
                l])
            fits[[i]] = update.pml(fits[[i]], tree = tree)
            ll[, i] = fits[[i]]$lv
        }
        lv = drop(ll %*% omega)
        loglik1 = sum(weight * log(lv))
        pen =  - 0.5 * lambda * t(thetanew) %*% KM %*% thetanew
        loglik1 = loglik1 + pen
        eps = abs(loglik1 - loglik)
        theta = exp(thetanew)
        loglik <- loglik1
        iter = iter + 1
#        print(iter)   
       }
       if(optOmega){
            res = optWPen(ll, weight, omega, pen)
            omega = res$p
            for (i in 1:m) {
                pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
                fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
                }
            } 
        lv = drop(ll %*% omega)
        loglik1 = sum(weight * log(lv))
        loglik0 =loglik1
        loglik1 = loglik1 - 0.5 * lambda * t(thetanew) %*% KM %*% thetanew
        eps0 = abs(loglik1 - loglik)
        theta = exp(thetanew)
        loglik <- loglik1
        iter0 = iter0 + 1
        print(loglik)  
    }

    for (i in 1:m) {
        pl0 <- ll[, -i, drop = FALSE] %*% omega[-i]
        fits[[i]] <- update(fits[[i]], llMix = pl0, wMix = omega[i])
    }
    df = sum(diag(solve(H + lambda * KM, H)))
    penalty <- list(lambda=lambda, K=KM, thetanew=thetanew, ploglik=loglik)
    object$omega = omega
    object$df[1, 1] = df
    object$df[1, 2] = 1
    object$fits = fits
    object$logLik = loglik0
    object$penalty = penalty
    object
}

optWPen = function (ll, weight, omega, pen, ...) 
{
    k = length(omega)
    nenner = 1/omega[1]
    eta = log(omega * nenner)
    eta = eta[-1]
    fn = function(eta, ll, weight, pen) {
        eta = c(0, eta)
        p = exp(eta)/sum(exp(eta))
        res = sum(weight * log(ll %*% p)) + pen
        res
    }
    if (k == 2) 
        res = optimize(f = fn, interval = c(-3, 3), lower = -3, 
            upper = 3, maximum = TRUE, tol = .Machine$double.eps^0.25, 
            ll = ll, weight = weight, pen = pen)
    else res = optim(eta, fn = fn, method = "L-BFGS-B", lower = -5, 
        upper = 5, control = list(fnscale = -1, maxit = 25), 
        gr = NULL, ll = ll, weight = weight, pen=pen)
    p = exp(c(0, res[[1]]))
    p = p/sum(p)
    result = list(par = p, value = res[[2]])
    result
}

	



score4 <- function (fit, trans = FALSE) 
{
    tree = fit$tree
    eig = fit$eig
    .dat <- NULL
    datp = rnodes(fit, TRUE)
    m = dim(.dat)[1]
    g = fit$g
    bf = fit$bf
    w = fit$w
    parent <- tree$edge[, 1]
    child <- tree$edge[, 2]
    nTips = min(parent) - 1
    l = length(child)
    sc = numeric(l)
    weight = fit$weight
    f <- fit$ll.0
    for (j in 1:m) f = f + (w[j] * .dat[[j, (nTips + 1)]]) %*% 
        bf
    d2l = score3(fit)
    dl = matrix(0, length(weight), l)
    ff0 = numeric(length(weight))
    for (i in 1:l) {
        elx = tree$edge.length[i]
        ff = ff0
        dP = getdP2(elx, eig, g)
        for (j in 1:m) {
            ff = ff + (datp[[j, child[i]]] * (.dat[[j, child[i]]] %*% 
                dP[[j]])) %*% (w[j] * bf)
        }
        dl[, i] = ff
        sc[i] = sum(weight * dl[, i]/f)
    }
    F = matrix(0, l, l)
    for (i in 1:l) {
        for (j in i:l) {
            F[i, j] = sum(weight * (f * d2l[[i, j]] - (dl[, 
                i] * dl[, j]))/(f * f))
        }
    }
    d = diag(F)
    F = F + t(F)
    diag(F) = d
    names(sc) = child
    dimnames(F) = list(child, child)
    result = list(sc = sc, F = -F, el = tree$edge.length, d2l=d2l)
    result
}


score3 = function (fit, ...) 
{
    tree = fit$tree
    eig = fit$eig
    dat = fit$data[tree$tip.label]
    g = fit$g
    bf = fit$bf
    w = fit$w
    q = length(tree$tip.label)
    node <- tree$edge[, 1]
    edge <- tree$edge[, 2]
    m = length(edge) + 1
    el <- tree$edge.length
    l <- length(tree$edge.length)
    P <- getP(el, eig, g)
    dP <- getdP2(el, eig, g)
    d2P <- getd2P2(el, eig, g)
    nr <- as.integer(attr(fit$dat, "nr"))
    nc <- as.integer(attr(fit$dat, "nc"))
    node = as.integer(node - min(node))
    edge = as.integer(edge - 1)
    nTips = as.integer(length(tree$tip))
    mNodes = as.integer(max(node) + 1)
    res <- vector("list", l*l)
    attr(res,"dim") <- c(l,l)
    for(i in 1:l){
        for(j in i:l){         
        Ptmp=P
        Ptmp[,i] <- dP[,i]
        Ptmp[,j] <- dP[,j]
        if(j==i)Ptmp[,i] = d2P[,i]
        tmp=numeric(nr) 
        for(k in 1:length(w)){ 
         
        tmp = tmp+ drop(.Call("LogLik", dat[1:q], Ptmp[k,], nr, nc, node, edge, nTips, 
            mNodes, PACKAGE = "phangorn")[[1]] %*% (w[k]*bf))
        }
        res[[i,j]] <- tmp
       }
    }
    res 
}



